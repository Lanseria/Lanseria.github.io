<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cookie实用原理总结</title>
    <url>/2019/09/10/Cookie%E5%AE%9E%E7%94%A8%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>此篇文章需要你掌握有关 Javascript | Web | HTTP 的基础知识。阅读时长约为5分钟。</p>
</blockquote>
<p>其实作为一名现代的前端开发者，<code>Cookie</code> 的这个概念几乎不用接触，这个是上个时代遗留下来的东西，了解它不乏有点困惑。但新的技术总是会与老技术相互碰撞，可能让后端自行带上 <code>Token</code> 等一些信息，<code>Cookie</code> 是一种最方便的方法了。所以本篇文章，我们就来讲讲 <code>Cookie</code> 有哪些有用的地方，与其他值得注意使用的地方。</p>
<a id="more"></a>

<h1 id="一、Cookie-的出现"><a href="#一、Cookie-的出现" class="headerlink" title="一、Cookie 的出现"></a>一、Cookie 的出现</h1><p><code>Cookie</code> 的用途主要是用来解决 <code>HTTP</code> 无状态的问题，我们都知道 <code>HTTP</code> 是没有状态的，也就是说我们每次的请求其实都是无状态的，如果不是 <code>Javascript</code> 可以主动设置请求头等信息的话，服务器是基本无法知道你是谁的。所以一般 <code>Cookie</code> 结合服务端的<code>Session</code> 会话功能，可以在你浏览并登陆之后，直到你退出页面都知道你是谁，你的商品到底加入到了谁的购物车。</p>
<p>除了提供可持续的状态，<code>Cookie</code> 还可以支持你的离线后再次记住你的功能。因为 <code>Cookie</code> 是可以设置过期时间（但不能永久，主动的清除缓存也会失效）。可是这样看起来 <code>Cookie</code> 是不是过于强大了呢？所以其实不好好用 <code>Cookie</code> 可能会造成一些人的滥用，从而导致用户的信息被盗等问题。</p>
<h1 id="二、Cookie-到底怎么用？"><a href="#二、Cookie-到底怎么用？" class="headerlink" title="二、Cookie 到底怎么用？"></a>二、Cookie 到底怎么用？</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"yummy_cookie=choco;domain=.icanvip.net"</span>;</span><br></pre></td></tr></table></figure>

<p>其实这一句代码就可以用了，虽然不怎么好用看起来，但是它包含了 <code>Cookie</code> 的读取与设置，所以非常好上手。</p>
<blockquote>
<p>以下可选的 <code>cookie</code> 属性值可以跟在键值对后，用来具体化对 <code>cookie</code> 的设定/更新，使用分号以作分隔：</p>
</blockquote>
<ul>
<li>;path=path (例如 ‘/‘, ‘/mydir’) 如果没有定义，默认为当前文档位置的路径。</li>
<li>;domain=domain (例如 ‘example.com’， ‘subdomain.example.com’) 如果没有定义，默认为当前文档位置的路径的域名部分。与早期规范相反的是，在域名前面加 . 符将会被忽视，因为浏览器也许会拒绝设置这样的cookie。如果指定了一个域，那么子域也包含在内。</li>
<li>;max-age=max-age-in-seconds (例如一年为60 * 60 * 24 *365)</li>
<li>;expires=date-in-GMTString-format 如果没有定义，cookie会在对话结束时过期<br>这个值的格式参见Date.toUTCString() </li>
<li>;secure (cookie只通过https协议传输)</li>
</ul>
<blockquote>
<p>cookie的值字符串可以用encodeURIComponent()来保证它不包含任何逗号、分号或空格(cookie值中禁止使用这些值).</p>
</blockquote>
<p>上面也是摘自 <code>https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie</code> 说的也是十分清楚，cookie 有哪些值可以设置。</p>
<h1 id="三、Cookie-中的Q-amp-A"><a href="#三、Cookie-中的Q-amp-A" class="headerlink" title="三、Cookie 中的Q&amp;A"></a>三、Cookie 中的Q&amp;A</h1><h2 id="1-能设置或读取子域的-cookie-吗"><a href="#1-能设置或读取子域的-cookie-吗" class="headerlink" title="1. 能设置或读取子域的 cookie 吗?"></a>1. 能设置或读取子域的 <code>cookie</code> 吗?</h2><p>不行! 只能向当前域或者更高级域设置 <code>cookie</code></p>
<p>例如 <code>client.com</code> 不能向 <code>a.client.com</code> 设置 <code>cookie</code> , 而 <code>a.client.com</code>  可以向 client.com 设置 <code>cookie</code></p>
<p>读取 <code>cookie</code> 情况同上</p>
<p>所以，如果你想在多个子域名下共享用户状态的话，可以利用这个原理进行对根域名的 Cookie 设置，这样其他子域名包含根域名的网址都可以读取到这个用户的状态。</p>
<h2 id="2-客户端设置-cookie-与服务端设置-cookie-有什么区别"><a href="#2-客户端设置-cookie-与服务端设置-cookie-有什么区别" class="headerlink" title="2. 客户端设置 cookie 与服务端设置 cookie 有什么区别?"></a>2. 客户端设置 <code>cookie</code> 与服务端设置 <code>cookie</code> 有什么区别?</h2><p>无论是客户端还是服务端, 都只能向自己的域或者更高级域设置 <code>cookie</code><br>例如 <code>client.com</code> 不能向 <code>server.com</code> 设置 <code>cookie</code> , 同样 <code>server.com</code>  也不能向 <code>client.com</code> 设置 <code>cookie</code><br>服务端可以设置 <code>httpOnly: true</code>, 带有该属性的cookie客户端无法读取<br>客户端只会带上与请求同域的 <code>cookie</code>, 例如 <code>client.com/index.html</code> 会带上 <code>client.com</code> 的 <code>cookie</code>,<br><code>server.com/app.js</code> 会带上 <code>server.com</code> 的 <code>cookie</code>, 并且也会带上 <code>httpOnly</code> 的<code>cookie</code><br>但是, 如果是向服务端的 <code>ajax</code> 请求, 则不会带上 <code>cookie</code> , 详情见第三个问题</p>
<h2 id="3-同域-跨域ajax请求到底会不会带上-cookie"><a href="#3-同域-跨域ajax请求到底会不会带上-cookie" class="headerlink" title="3. 同域/跨域ajax请求到底会不会带上 cookie ?"></a>3. 同域/跨域<code>ajax</code>请求到底会不会带上 <code>cookie</code> ?</h2><p>这个问题与你发起 <code>ajax</code> 请求的方式有关<br> <code>fetch</code> 在默认情况下, 不管是同域还是跨域 <code>ajax</code> 请求都不会带上 <code>cookie</code> , 只有当设置了 <code>credentials</code> 时才会带上该 <code>ajax</code> 请求所在域的 <code>cookie</code> , 服务端需要设置响应头 <code>Access-Control-Allow-Credentials: true</code>, 否则浏览器会因为安全限制而报错, 拿不到响应</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(url, &#123;</span><br><span class="line">    credentials: <span class="string">"include"</span>, <span class="comment">// include, same-origin, omit</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p> <code>axios</code> 和 <code>jQuery</code> 在同域 <code>ajax</code> 请求时会带上 <code>cookie</code> , 跨域请求不会, 跨域请求需要设置 <code>withCredentials</code> 和服务端响应头 </p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'http://server.com'</span>, &#123;<span class="attr">withCredentials</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure>

 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> $.ajax(&#123;</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">    url: <span class="string">'http://server.com'</span>,</span><br><span class="line">    xhrFields: &#123;</span><br><span class="line">        withCredentials: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以上原答案来自</p>
<blockquote>
<p>作者：碎碎酱<br>链接：<a href="https://juejin.im/post/5b5df0aee51d451998415485" target="_blank" rel="noopener">https://juejin.im/post/5b5df0aee51d451998415485</a><br>来源：掘金</p>
</blockquote>
<h1 id="四、最新的-Cookie-安全保证-—-Cookie-的-SameSite-属性"><a href="#四、最新的-Cookie-安全保证-—-Cookie-的-SameSite-属性" class="headerlink" title="四、最新的 Cookie 安全保证 — Cookie 的 SameSite 属性"></a>四、最新的 Cookie 安全保证 — Cookie 的 SameSite 属性</h1><p>Cookie 的SameSite属性用来限制第三方 Cookie，从而减少安全风险。<br>它可以设置三个值。</p>
<ul>
<li>Strict</li>
<li>Lax</li>
<li>None</li>
</ul>
<h2 id="1-Strict"><a href="#1-Strict" class="headerlink" title="1. Strict"></a>1. Strict</h2><p> <code>Strict</code> 最为严格，完全禁止第三方 <code>Cookie</code>，跨站点时，任何情况下都不会发送 <code>Cookie</code>。换言之，只有当前网页的 <code>URL</code> 与请求目标一致，才会带上 <code>Cookie</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: CookieName=CookieValue; SameSite=Strict;</span><br></pre></td></tr></table></figure>
<p>这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 <code>GitHub</code> 链接，用户点击跳转就不会带有 <code>GitHub</code> 的 <code>Cookie</code>，跳转过去总是未登陆状态。</p>
<h2 id="2-Lax"><a href="#2-Lax" class="headerlink" title="2. Lax"></a>2. Lax</h2><p> <code>Lax</code> 规则稍稍放宽，大多数情况也是不发送第三方 <code>Cookie</code>，但是导航到目标网址的 Get 请求除外。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: CookieName=CookieValue; SameSite=Lax;</span><br></pre></td></tr></table></figure>

<p>导航到目标网址的 <code>GET</code> 请求，只包括三种情况：链接，预加载请求，<code>GET</code> 表单。详见下表。</p>
<p><a href="http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html</a></p>
<p>设置了 <code>Strict</code> 或 <code>Lax</code> 以后，基本就杜绝了 <code>CSRF</code> 攻击。当然，前提是用户浏览器支持 <code>SameSite</code> 属性。</p>
<h2 id="3-None"><a href="#3-None" class="headerlink" title="3. None"></a>3. None</h2><p><code>Chrome</code> 计划将Lax变为默认设置。这时，网站可以选择显式关闭 <code>SameSite</code> 属性，将其设为 <code>None</code> 。不过，前提是必须同时设置 <code>Secure</code> 属性（ <code>Cookie</code> 只能通过 <code>HTTPS</code> 协议发送），否则无效。</p>
<p>下面的设置无效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: widget_session=abc123; SameSite=None</span><br></pre></td></tr></table></figure>
<p>下面的设置有效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: widget_session=abc123; SameSite=None; Secure</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>原理</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>Cookie</tag>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode开发技巧-远程利用linux开发</title>
    <url>/2019/08/09/vscode%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7-%E8%BF%9C%E7%A8%8B%E5%88%A9%E7%94%A8linux%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>此篇文章需要你掌握有关 Git | Vscode | Bash 的基础知识。阅读时长约为5分钟。</p>
</blockquote>
<p>作为程序开发者，平时开发我想大多数都是在 <code>Windows</code> 上开发的，如果平时也不会接触计算机中高级的成分，我想你也不需要用到 <code>Linux</code> 等一些系统，其他编译问题可能会遇到，但百度一下都能够解决掉。所以这篇文章自认为是给那些需要装逼，或者需要更不易出错，需要更快的编译时间等那些人看的，在我看来， <code>Linux</code> 上编译的速度远远比 <code>Windows</code> 高得多，所以我开始将开发工作搬运到了 <code>Linux</code> 机器中，一来，我的电脑不会太卡，可以继续流畅地浏览网页。二来，开发速度得到了快速的提升。如果你对此有兴趣的话，我们就马上开始准备吧（这里只讲 <code>vscode</code> 编辑器的远程开发配置）</p>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><img src="/img/2019-08-09-1.png" class="" title="Vscode编辑器">

<ul>
<li>Vscode 编辑器(我用的是1.37版本)</li>
<li>Git windows 安装包 (我的用是git version 2.22.0.windows.1)</li>
<li>以及一些Vscode关键词用来搜索(remote是搜索关键字)</li>
</ul>
<img src="/img/2019-08-09-2.png" class="" title="remote是搜索关键字">

<p>红框是必须要安装的哦，其他也推荐安装，万一没成功我可不知道😂。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>安装完这些插件之后，这时你可以看到你的左侧会多一个PC的图标</p>
<img src="/img/2019-08-09-3.png" class="" title="PC的图标">

<p>点开之后会出现类似截图一样的链接(不过这些链接一般是不可能链接成功的)</p>
<img src="/img/2019-08-09-4.png" class="" title="链接">

<p>你可能会问，为什么我没有你出现的这四个链接，因为我git的ssh目录做了配置，这也是我为什么发现这样的可行性。如何打开你的ssh配置？<br>只要右击打开git-bash命令行输入 code ~/.ssh/ 即可</p>
<img src="/img/2019-08-09-5.png" class="" title="git-bash">

<img src="/img/2019-08-09-6.png" class="" title="配置过的config文件">

<p>如果是我的话会打开这样之前已经被我配置过的 <code>config</code> 文件，如果你是空白的话，你需要自行创建一个config文件，如何创建我在之前的文章已经提过，你可以直接翻看的文章进行理解与配置</p>
<p><a href="/2018/03/07/ssh%E5%AF%86%E9%92%A5%EF%BC%8C%E4%B8%80%E4%B8%AA%E9%92%A5%E5%8C%99%E8%B5%B0%E5%A4%A9%E4%B8%8B/">相关SSH配置链接</a></p>
<p>然后开始填写你Linux ssh配置, 这些配置信息如何来，看上面链接上的文章即可，<br>你需要知道你的服务器的IP地址, sshkey 域名(没有可以利用hosts配置)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#txsshcq</span><br><span class="line">Host ivhik.cn # 域名(绑定你的服务器IP)</span><br><span class="line">  Port 22 #端口</span><br><span class="line">  HostName ivhik.cn </span><br><span class="line">  StrictHostKeyChecking no</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa_ssh # 你的私钥</span><br><span class="line">  User root #你的登陆用户名称</span><br></pre></td></tr></table></figure>

<p>配置之后，还需要移除 <code>Windows</code> 自带的 <code>ssh</code><br>需要管理员运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Remove-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0</span><br></pre></td></tr></table></figure>
<p>然后将 <code>git</code> 的 <code>/bin</code> 目录添加在 <code>windows path</code> 环境变量中</p>
<p>接下来你就可以远程编辑你服务器里的代码了</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Vscode</tag>
        <tag>remote</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>git 分支名的一些见解</title>
    <url>/2018/12/28/git-%E5%88%86%E6%94%AF%E5%90%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%81%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>此篇文章需要你掌握有关 Git | CMD | Bash 的基础知识。阅读时长约为5分钟。</p>
</blockquote>
<p>首先说说为什么会写这篇文章。公司可以很少人真正能够了解 <code>Git</code> 分支管理流程，命名也是一团糟，原因也十分简单，大家都是从 <code>SVN</code> 转移过来的，这种单纯的文件保存系统，就跟 <code>IDEA</code>，<code>STS</code> 的文件历史系统保管一样，简单，理解起来容易，但是与 <code>Git</code> 的所具有的功能差别就大了，<code>Git</code> 就是来解决项目中的多人同步开发的问题，合理的分支管理甚至能够帮助你查错与排错，高效地二分查找命令等等。所以这篇文章就是来讲明白甚至提出自己的一些见解来让公司的项目更加的快速迭代与开发。</p>
<a id="more"></a>

<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><blockquote>
<p>分支在 <code>Git</code> 中是非常重要的一个知识点， <code>Git</code> 的所有命令都是围绕这个操作的。</p>
</blockquote>
<img src="/img/2018-12-28-1.jpg" class="" title="常见项目分支流">

<p>通常情况下, 分支一般只会存在下边几种情况: </p>
<ul>
<li>master：与线上版本保持绝对一致；</li>
<li>develop：开发分支，由下文提到的 <code>release</code> 、 <code>feature</code> 、 <code>hotfix</code> 分支合并过后的代码；</li>
<li>feature：实际功能点开发分支，建议每个功能新建一个 <code>feature</code> ， 具有关联关系的功能公用一个 <code>feature</code> 分支；</li>
<li>release：每一次开发完成之后，从 <code>develop</code> 创建出来的分支，以此分支为基准，进行测试；</li>
<li>hotfix：该分支主要用于修复线上bug；</li>
<li>refactor：需要大量重构(公司不存在架构师的情况下)；</li>
</ul>
<p>命名规范约定如下：</p>
<ul>
<li>feature分支命名：feature/name</li>
<li>release分支命名：release/name</li>
<li>hotfix分支命名：hotfix/name</li>
</ul>
<blockquote>
<p>比如有一个「优化分布式Session」的需求，可在develop分支的基础上创建新分支 <code>feature/optimize_distributed_session</code> 进行开发，开发完成后合并到 <code>develop</code> 分支。</p>
</blockquote>
<h2 id="分支详细介绍和处理流程"><a href="#分支详细介绍和处理流程" class="headerlink" title="分支详细介绍和处理流程"></a>分支详细介绍和处理流程</h2><h3 id="master分支"><a href="#master分支" class="headerlink" title="master分支"></a>master分支</h3><p>主分支，与线上运行的版本始终保持一致，任何时候都不要直接修改master分支。</p>
<p>一个版本的release分支、hotfix分支开发完成后，会合并代码到master分支，也就是说master分支主要来源于release分支和hotfix分支。</p>
<h3 id="develop分支"><a href="#develop分支" class="headerlink" title="develop分支"></a>develop分支</h3><p>开发分支，始终保持最新完成以及bug修复后的代码，新增功能时基于该分支创建feature分支。</p>
<p>一个版本的release分支、hotfix分支开发完成后，也会合并到develop分支，另外，一个版本的feature功能开发完成后，也会合并到develop分支。也就是说develop分支来源于feature、release、hotfix分支。</p>
<h3 id="feature分支"><a href="#feature分支" class="headerlink" title="feature分支"></a>feature分支</h3><p>开发新功能或优化现有功能时，会创建feature分支，以develop为基础创建。一般会有多个功能同时开发，但上线时间可能不同，在适当的时候将特定的feature分支合并到develop分支，并创建release分支，进入测试状态。</p>
<h3 id="release分支"><a href="#release分支" class="headerlink" title="release分支"></a>release分支</h3><p>当一组feature开发完成，会首先合并到develop分支，开始进入提测阶段时，会创建release分支。</p>
<p>以release分支代码为基准提测，测试过程中若存在bug需要修复，则直接由开发者在release分支修复并提交。</p>
<p>测试完成之后，合并release分支到master和develop分支，此时master为最新代码，用作上线。</p>
<h3 id="hotfix分支"><a href="#hotfix分支" class="headerlink" title="hotfix分支"></a>hotfix分支</h3><p>线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支，修复完成后，需要合并到master分支和develop分支。</p>
<h3 id="特殊情况处理和注意点"><a href="#特殊情况处理和注意点" class="headerlink" title="特殊情况处理和注意点"></a>特殊情况处理和注意点</h3><p>develop分支已存在未上线的feature代码, 此时需要紧急上线一个新功能, 但develop的代码不能上，如何处理 ？</p>
<p>以master为基线创建feature， 在完成之后，代码合并到master分支；<br>为了保证develop是最新代码，需要从master合并到develop分支；</p>
<p>以develop为基线，创建了f1和f2两个feature分支之后, f1,f2开发一半的时候，发现两个分支代码需要有依赖怎么办 ？</p>
<p>最好在开发开始前确定两个功能是否相关,若相关则只创建一个分支,两个功能在一起开发;<br>如果已经创建，则需要合并到一个分支；</p>
<h3 id="保证-commit-整洁"><a href="#保证-commit-整洁" class="headerlink" title="保证 commit 整洁"></a>保证 commit 整洁</h3><p>一定要保证commit历史记录的整洁，代码合并时，根据情况选择merge或rebase;<br>使用rebase注意，一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作；<br>提交说明规范：</p>
<p>提交说明最好限制在一行以内，50个字符以下，简明扼要地描述更新内容，空开一行后，再展开详细注解；<br>如果关联jira，写上jira地址；</p>
<blockquote>
<p>借鉴文章<br>作者：情情说<br>链接：<a href="https://juejin.im/post/5aa7e8a6f265da239f070d82" target="_blank" rel="noopener">https://juejin.im/post/5aa7e8a6f265da239f070d82</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h3 id="线下最好用CMD命令行操作一下"><a href="#线下最好用CMD命令行操作一下" class="headerlink" title="线下最好用CMD命令行操作一下"></a>线下最好用CMD命令行操作一下</h3>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Branch</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>Node的一些基础知识</title>
    <url>/2018/11/11/Node%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>此篇文章需要你掌握有关 Node.js | javascript | CMD | Bash 的基础知识。阅读时长约为5分钟。</p>
</blockquote>
<p>快半年没有在这里写东西了，这次就简单讲讲 <code>Node.js</code> 的一些必要知识，方便刚学习的人跨过一些坑。首先来看看 <code>Node.js v10.13.0</code> 又更新了什么功能。</p>
<img src="/img/2018-11-11-1.jpg" class="" title="Nodejs最近又更新了">

<a id="more"></a>

<h1 id="Node-v10-13-0-更新"><a href="#Node-v10-13-0-更新" class="headerlink" title="Node v10.13.0 更新"></a>Node v10.13.0 更新</h1><p>对我来说一下几点有比较大的改动：</p>
<ol>
<li><code>npm-gyp</code> 等一系列工具的安装选项<br>要知道，以前如果没有全局安装这些编译环境的话，有些好用的包是用不了的，经常会报错，安装失败（毕竟 <code>Node.js</code> 也需要外来编译成的帮助）。现在你只需要安装Nodejs时，勾上这个选项， <code>Nodejs</code> 就会在安装完 <code>Nodejs</code> 之后帮你安装全部的编译环境，免去失败的或者安装不全的烦恼。</li>
<li><code>V8</code> 已升级至 <code>6.6</code> 版本。</li>
<li><code>OpenSSL</code> 升级至 <code>1.1.0h</code> 版本。</li>
<li>新增 <code>console.table()</code> 方法。</li>
<li><code>crypto.createCipher()</code> 和 <code>crypto.createDecipher()</code> 方法已被弃用，并被 <code>crypto.createCipheriv()</code> 和 <code>crypto.createDecipheriv()</code> 替代。<code>decipher.finaltol()</code> 方法已弃用。<code>crypto.DEFAULT_ENCODING</code> 属性已弃用。新增 <code>ECDH.convertKey()</code> 方法。<code>crypto.fips</code> 属性已弃用。</li>
</ol>
<h1 id="NPM-包的使用"><a href="#NPM-包的使用" class="headerlink" title="NPM 包的使用"></a>NPM 包的使用</h1><p>这里不多说，国内镜像三步走。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm set registry https://registry.npm.taobao.org</span><br><span class="line">npm set disturl https://npm.taobao.org/dist</span><br><span class="line">npm i -g mirror-config-china --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h1 id="NPM-和-Yarn-的区别"><a href="#NPM-和-Yarn-的区别" class="headerlink" title="NPM 和 Yarn 的区别"></a>NPM 和 Yarn 的区别</h1><p>虽然大家都是包管理工具，但 <code>yarn</code> 的安装速度的确不必 <code>npm</code> 慢，可以这么说， <code>yarn</code> 是一种实验性质的包管理，它具有大家先进的理念与想法。最近 <code>yarn</code> 好像又推出了像 <code>java maven</code> 一样的包管理形式，让包不直接放在项目文件夹这么占用地方，放在公共的本地仓库会使更佳的解决办法。</p>
<h1 id="lock-文件"><a href="#lock-文件" class="headerlink" title=".lock 文件"></a>.lock 文件</h1><p>如果你在国外，这个不用操心，但是你在国内，还是希望你在 <code>git</code> 项目中能够移除这样的包锁定文件，这可能导致你的自动化集成失败，原因就是你用的是国内的镜像，国外访问是过慢的。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>NPM</tag>
        <tag>镜像</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH密钥，一个钥匙走天下</title>
    <url>/2018/03/07/ssh%E5%AF%86%E9%92%A5%EF%BC%8C%E4%B8%80%E4%B8%AA%E9%92%A5%E5%8C%99%E8%B5%B0%E5%A4%A9%E4%B8%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>此篇文章需要你掌握有关 ssh-key | linux | git配置的基础知识。阅读时长约为5分钟。</p>
</blockquote>
<p>前几天，我在腾讯云用 ssh 配置完登录密钥后，才发现 ssh config 文件并不是必须的，你确保你的 ssh key 私钥能不被泄露的话，或者即使泄露成本也很低，我就推荐你这样做。是真的很方便，只要你随手拿着你的唯一的 ssh 私钥就可以了。</p>
<a id="more"></a>
<h1 id="不用一个私钥的方法"><a href="#不用一个私钥的方法" class="headerlink" title="不用一个私钥的方法"></a>不用一个私钥的方法</h1><ol>
<li>比如你经常用到 github ，你就需要随时 push and pull 仓库的代码。</li>
<li>同时你公司还要用到 gitlab 的仓库，于是这个坑就出来了。如果你当时什么也不懂，你在为创建 gitlab 的 ssh key 时，你就会覆盖掉原先的 github 的 ssh key 所以你只能在其中选一个。</li>
<li>解决方案也有，就是在 ~/.ssh/ 下创建一个 config 文件，配置相应信息，让 ssh 能够通过配置去访问不同的私钥，通过拿着不同的私钥去 pass 不同网站仓库严格的验证 validate</li>
</ol>
<p><strong>config 文件 参考</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#oschina  </span><br><span class="line">Host git.coding.net</span><br><span class="line">    HostName git.coding.net</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_coding</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    User youemail@qq.com</span><br><span class="line"></span><br><span class="line">#github</span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_home</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    User youemail@qq.com</span><br><span class="line">#gitlab</span><br><span class="line">Host gitlab.com</span><br><span class="line">    HostName gitlab.com</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_cpn</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    User youemail@qq.com</span><br><span class="line">#txssh</span><br><span class="line">Host 115.159.27.203</span><br><span class="line">    StrictHostKeyChecking no</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_ssh</span><br></pre></td></tr></table></figure>
<ol>
<li>这个配置如果你需要通过 ssh 登录 linux 的话，看最后一个配置就可以了，就可以实现无密登录</li>
</ol>
<h1 id="实现一个私钥走天下"><a href="#实现一个私钥走天下" class="headerlink" title="实现一个私钥走天下"></a>实现一个私钥走天下</h1><ol>
<li>只要你在一开始就生成一个私钥和公钥就可以了，以后 github 或者 gitlab 再者 linux ssh key 都使用同一个公钥文件就可以实现了。</li>
<li>你不需要再配置 config 了，或者在另一台电脑上再去配置 ssh-key 使你的 key 管理不过来</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>ssh-key</tag>
        <tag>密钥</tag>
        <tag>登录</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>2018年，新年快乐，定个小目标</title>
    <url>/2018/01/01/2018%E5%B9%B4%EF%BC%8C%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%8C%E5%AE%9A%E4%B8%AA%E5%B0%8F%E7%9B%AE%E6%A0%87/</url>
    <content><![CDATA[<blockquote>
<p>今年的2018还是跟以前一样，一个人的跨年，一个人的节日，在此，争取在下个元旦能够找到一个女票，如果这一年比较忙的话，会孤独惯了，那就真的随天命勒。</p>
</blockquote>
<p>总结过去一年，发现大学的生活已经离我而去，每次去学校都带有陌生的感觉，熟悉的人已不再经常碰到，满是新生的气息。所以带有恐惧感靠近学校也想早点离开这个地方，这个在我眼中的象牙塔。</p>
<p>2018年还是一个变化比较大的一年：</p>
<p>比特币从今年开始被大众关注，特别是5月12日，比特币勒索病毒WannaCry，让人们认识到这种黑客货币的存在。这是比特币的一年。</p>
<p>不过同时也是人工智能的一年：5月27日，柯洁以0:3败给AlphaGo，泪洒当场。之后的一次网上对剧中，击败众多选手，让人工智能这个词语放大，之后火起来的不管是深度学习还是大数据都吸引人们的眼球。</p>
<a id="more"></a>
<p>当然作为果粉也不会忘记今年的苹果公司在手机上转型的一年。可以看到异性屏的发布与A11芯片的加入，神经网络的学习在未来越来越重要了。</p>
<p>还有很多很多，这里就不再一一赘述。</p>
<p>世界发生着改变，同样我觉得一个人一年内世界观不与时俱进的话，我认为他可能过得也太舒服了。下面也总结的我的世界观的变化：</p>
<p>在感情上：我觉得更加奔放了。对一些难以说出口的词语也不嫌而避之。不怕被别人说自己很不纯。不过这些还是要在适当场合说说。<br>另外，这一年也是觉得感情的哪一方都应该去理解下对方的感受。在今年七夕节被一个追了我2年的女孩又告白了。她喜欢用酒去避讳这写尴尬的语境，所以那晚我被缠了1个小时。。想想是有点可怕但是还是跟她继续聊下去，希望她能知道。<br>对于她，我认为她的勇气真的非同常人，所以我也希望今后她的感情能够一直那么勇敢，我是不想打断她的积极性的。<br>还有就是缘分，缘分尽了就真的没有什么好讲了。一个人不喜欢，就是真的不喜欢，即使让她依让她抱，都是安慰她。<br>会想起高中三年一直有暗恋的对象。虽然感觉也是先被送礼物的，但是没抓住就是后悔，到现在就是无怨无悔，即使现在她有些电脑上的问题问我，我心里也没有像以前一样追在她后面，默默看她进一条街巷，回住的地方，没有那种一看就是几分钟，一想就是满满欣慰的体会了。<br>所以，现在的我还是一如既往的学习这些，多跟女性朋友聊天，问问题。希望在真的遇到自己能爱的人，能够全心全意对她。</p>
<p>生活上：开始注重身体，作为一名程序员，没有好的身体就没有人生。我会加油，在今年能够在锻炼上有所突破。</p>
<p>金钱上：我在今年如实找到了一份工作，住的还行，人到很少，就我和技术主管两个人了。买了新手机和新手表用来锻炼。开始注重工具带来的效率。希望下一年能够买个台式可以玩玩游戏，买个苹果电脑来敲敲代码。同时希望下个月就能涨工资，顺便问问实习什么时候结束，我在公司以后的职业前景会是如何。</p>
<p>最后呢，我写个择偶标准吧。看看下年会不会将低许多。<br>人好是第一位；<br>有学习能力，不路痴；<br>勤快的家伙，有娱乐游戏的爱好；<br>如果额外技能如会跳舞，会唱歌就更好了；</p>
<p>应该要求不过分吧。。</p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>目标</tag>
      </tags>
  </entry>
  <entry>
    <title>VsCode编辑器的设置技巧（JavaScript格式化篇）</title>
    <url>/2017/12/22/VsCode%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E8%AE%BE%E7%BD%AE%E6%8A%80%E5%B7%A7%EF%BC%88JavaScript%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一个IT工作者，不管你是前端还是后端，甚至是大数据分析师，只要你接触代码，你总会要去选择一款方便的编辑器来配合你的工作。</p>
<p>我这里来列举下通常情况下各个编辑器会被哪类人使用</p>
<p><code>C++/C</code> 入门者：<a href="http://www.codeblocks.org/" target="_blank" rel="noopener">CodeBlocks</a>、 DevCpp、 Vc6++<br><code>Java</code> : ecilipse、 <a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">IntelliJ IDEA</a><br><code>Python</code>: <a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">PyCharm</a><br><code>HTML等前端</code>: <a href="http://www.dcloud.io/" target="_blank" rel="noopener">HBuilder</a><br><code>通用编辑器</code>: <a href="https://www.sublimetext.com/" target="_blank" rel="noopener">Sublime</a>、 <a href="https://atom.io/" target="_blank" rel="noopener">Atom</a>、 <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">vsCode</a></p>
<p>有一款好用的编辑器或者说是工具，就是一个IT工作者很好的利器，但是光有还不行，你至少要学会如何配置它，但是如果你还有额外的经理和能力，工具是开源的情况下，你就可以升级它。把他变成你所想要的模样。</p>
<a id="more"></a>
<h1 id="格式化的重要性"><a href="#格式化的重要性" class="headerlink" title="格式化的重要性"></a>格式化的重要性</h1><ol>
<li>格式化是一个程序员的基本素养，我看过那些换行都懒得换的，写出来的样子都没有左对齐，简直难以审阅</li>
<li>有良好的格式化能力，不仅帮你审阅代码时不疲劳，甚至可以减少代码出错的概率</li>
</ol>
<p>从而帮你平常的一些小痛苦中解脱出来</p>
<h1 id="编辑器的选择"><a href="#编辑器的选择" class="headerlink" title="编辑器的选择"></a>编辑器的选择</h1><p>编辑器，我这里还是以我在工作上的角度去编写，以 <code>VsCode</code> 配置来说一下 <code>Format</code> 技巧</p>
<p>不过还是要说说它的优点<br>相比大多数大型 <code>IDE</code> 而言，它的功能单一但是速度很快<br>相比 <code>ATOM</code> 等自由度甚高的来说，它稳定性高而且依赖群体人数多</p>
<h1 id="VsCode配置举例解说"><a href="#VsCode配置举例解说" class="headerlink" title="VsCode配置举例解说"></a>VsCode配置举例解说</h1><p>如果你是经常用 <code>javscript</code> 写项目的话，你会发现 <code>eslint</code> 的配置和 <code>VsCode</code> 的格式化有一些些冲突<br>特别当你复制下面这一段代码时</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">saveWorkbook</span> (<span class="params">xlsxName: string, wb: XLSX.WorkBook</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* write workbook (use type 'binary') */</span></span><br><span class="line">  <span class="keyword">const</span> wbout = XLSX.write(wb, &#123;<span class="attr">bookType</span>: <span class="string">'xlsx'</span>, <span class="attr">type</span>: <span class="string">'binary'</span>&#125;)</span><br><span class="line">  saveAs(<span class="keyword">new</span> Blob([s2ab(wbout)], &#123;<span class="attr">type</span>: <span class="string">'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'</span>&#125;), xlsxName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码在普通的 <code>eslint</code> 下是不会报错的，但是如果你将它复制一下，他就可能格式错乱了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">saveWorkbook</span>(<span class="params">xlsxName: string, wb: XLSX.WorkBook</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* write workbook (use type 'binary') */</span></span><br><span class="line">  <span class="keyword">const</span> wbout = XLSX.write(wb, &#123; <span class="attr">bookType</span>: <span class="string">'xlsx'</span>, <span class="attr">type</span>: <span class="string">'binary'</span> &#125;)</span><br><span class="line">  saveAs(<span class="keyword">new</span> Blob([s2ab(wbout)], &#123; <span class="attr">type</span>: <span class="string">'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'</span>&#125;), xlsxName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然不同的人，有不同的配置，这里不岔开去讲了</p>
<p>这里有亮点不同，我分别用中文与英文，还有我自己的理解去说</p>
<p><code>saveWorkbook(xls</code>:<code>saveWorkbook (xls</code><br>这个区别官方叫做 <code>在函数参数括号前定义空格处理</code><br>英文写法是 <code>insertSpaceBeforeFunctionParenthesis</code><br>其实英文的写法更好理解一些，叫做在方法名后参数列表前插入空格</p>
<p><code>XLSX.write(wb, {bookType: &#39;xlsx&#39;, type: &#39;binary&#39;})</code><br>定义非空括号的左括号后面和右括号前面的空格处理<br>英文简写 <code>insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces</code><br>以我的定义就是前大括号之后的空格与后大括号的空格加不加的问题</p>
<p>其它还有很多，我就不累述了，因为 <code>Vscode</code> 在翻译上做的挺不错的</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>VsCode</tag>
      </tags>
  </entry>
  <entry>
    <title>一直在督促别人学习，但知道这是无用功。直到他们走到这一步</title>
    <url>/2017/12/13/%E4%B8%80%E7%9B%B4%E5%9C%A8%E7%9D%A3%E4%BF%83%E5%88%AB%E4%BA%BA%E5%AD%A6%E4%B9%A0%EF%BC%8C%E4%BD%86%E7%9F%A5%E9%81%93%E8%BF%99%E6%98%AF%E6%97%A0%E7%94%A8%E5%8A%9F%E3%80%82%E7%9B%B4%E5%88%B0%E4%BB%96%E4%BB%AC%E8%B5%B0%E5%88%B0%E8%BF%99%E4%B8%80%E6%AD%A5/</url>
    <content><![CDATA[<blockquote>
<p>男女真的大多时候不是同一世界里的，虽然我遇见过女生最后选择了程序员，但刚开始走的路远比男生艰辛。可能是 C 语言语法没学好等等，不管怎样，基础就差了一个档次。</p>
</blockquote>
<p>可能有人会说前端容易啊！对，前端是容易的，但这也只是在前几年，现在的前端，你没有一定的面向对象的基础，你根本是很难学懂的。</p>
<h1 id="这篇文章是写给计算机专业的女生看的"><a href="#这篇文章是写给计算机专业的女生看的" class="headerlink" title="这篇文章是写给计算机专业的女生看的"></a>这篇文章是写给计算机专业的女生看的</h1><blockquote>
<p>回过头写：如果有计算机女生大触看，我这里说一句：“打扰了！打扰了！打扰了！”</p>
</blockquote>
<p>如果你真的不喜欢计算机，我还是劝你迟早放弃，找点设计或者你所喜欢的职业去试试，兴趣第一，这句话我一直存在我的口中。</p>
<a id="more"></a>
<p>但是我想，能选择计算机专业的女生，大多数还是对它有点喜欢的，至少认为它有点用，也是因为其它的专业我也不喜欢。。</p>
<p>的确，学好计算机你可以做许多工作，现在那个人不会计算机呢？当客服，你可以通过计算机查询问题来回答客户的问题；当会计你至少要学会Excel去统计数据吧；等等，最后如果你什么都不会，至少打打字也能赚点外快。</p>
<p>不过这些都是比较容易的职业，前景与方向都是不明朗的，不知道哪天AI出来就把这些职业代替掉了。所以学习计算机，当然是要充分理解计算机的原理，做个比一般的角色，当个有知识深度的人。至少至少，当你使用你每天都会打开的APP时，用PC端的QQ跟别人聊天时，上网站逛淘宝京东时，甚至锻炼打电话等等，我希望你能思考思考这些到底是怎么实现的。你可能会问，我为什么要知道这些东西，我想说的是，一，你每天都在接触的东西，都是依赖你现在所学的知识，体系，两者之间，如果你有很好的融汇贯通，你会对老师教的，课程视频里岔开来讲的问题有更深刻的理解；二，对以后自己做项目时，有更好的参考依据，就拿个比方来讲，最简单都是造轮子了，你想写个类似QQ的聊天项目（以后好方便找工作拿得出手）那你不仅平时要仔细观察QQ的界面组成，怎么改用代码写出来，还要观察通信方式是怎么实现的，如何实现，还是得靠你们现在已有的经验去推测。</p>
<p>所以平时多想问题的你，就与之前只会刷刷微信聊聊天的你产生了差别，兴趣也就可能从此产生。如果你对的说法没有大的感触，那你可能真的不想知道，可能计算机的这条路是不太适合你的，探索的精神是必须要有的。</p>
<h1 id="光有探索精神还不够"><a href="#光有探索精神还不够" class="headerlink" title="光有探索精神还不够"></a>光有探索精神还不够</h1><blockquote>
<p>探索只是给与你激发兴趣的方法，光想，光理论是远远不够的，这也是大部分女生到大学的学习计算机时的通病，看过我们的班的女生写个物理实验报告，整整地把A4纸两面都写满了，我当时脑中真是懵逼的，“哪来的那么多字？？？”，“哪里来的时间？（可能我偷偷打游戏的时候）”，“字写得这么好，一定很累吧。。”我看着自己简简单单的那几个字，真是心中有些敬仰了。</p>
</blockquote>
<p>不过这都是题外话，我高中好多人也是这样的，我也是尽力做这么多，毕竟老师要检查笔记嘛！</p>
<p>但是，学习计算机不一样，我们不一样🙃。刚开始，的确还是可以写写笔记，练练书法之类的。但是你到以后，真的记得过来嘛！</p>
<p>计算机的知识体系与其他有很大不同</p>
<ol>
<li>计算机，代码要求很高，错一个字母都不行</li>
<li>要记得代码方法甚多，一个语言的文档都几千页，根本难以用手写记录</li>
<li>英文很重要，充分理解计算机系的英语，对学习计算机有很大帮助</li>
<li>计算机唯一记忆不多而且可以略略而记的就是算法</li>
<li>提升编程能力方式：多敲代码，多看别人写的代码，多看新的代码</li>
</ol>
<p>应该还有很多，我这里只是以我的角度来看，也就是这几点，我观察过，大部分女生都难以做到（因为我教了 3 届的学弟学妹）</p>
<p>在这里呢！我举几个例子，看的的可以对号入座下：</p>
<ol>
<li>我班11个女生，没见过她们参加什么代码比赛，毕竟硬件专业，因为这对于他们来讲更需要动手能力。代码课似乎都只是按着代码敲敲，没有参加实验室之类的活动。</li>
<li>慧慧，一个计科班的女生，似乎参加过acm比赛，和培训，数据结构和算法的课都上的比我多，毕业算作是合格了，也跟我一起参加过计算机设计大赛。但是动手能力只能说一般，没有真正敲过一个项目，参与似乎也没有，练的最多也就是小例子，小Demo，入门教程，什么都是入门，对游戏也是比较吸引力，不过不会理财（这个就叉开话题了…），但是还是一样，笔记我看她还是手写，或者用word写，考试最后复习的时候也是。</li>
<li>另一个慧姐，也是同届计科班的学生，和团队参加过很多ACM比较，远比我厉害，英语过了四六级，上一个慧姐也是，担任着团支书，目前似乎准备着考研，好像她还参加过数学建模比赛，同样都是巨蟹座，不过，这样的过程，没有编程语言上的积累，似乎她的方向也很明确了，考研做研究方向，以后出国都是吃很有可能的，所以这是我们这等人学不来的，毕竟人家理论已经高到了另一个层次。</li>
<li>我带过的一个政法的一个15妹子，当初她跨界来学php也是让我感动，但最后还是没有坚持，估计技术的门槛还是拦住了她，因为我看到她的电脑还是旧的，估计是哥哥姐姐给的，学习计算机，电脑，笔记本是最基础的东西，那东西如果你没有过多要求，也就反映了你对计算机这门技术不当回事，我们都有计算机太卡，想砸电脑冲动的时候。</li>
<li>一个在暑假遇到的学妹，蒋柯，但是她带给我的感觉就是有那股学习的冲劲，有时上午结束后都是最后一个走，有时也会问问学长问题，问题也是自己尝试多边的问题，给我说了很多想法，这如果我再不帮她解决问题实在是说不过去了。现在她到实验室了，估计会有所作为吧。</li>
<li>当然也有很有潜力但还没遇到紧要关头，16级的王莉莉，她跟我说，对学什么都不太感兴趣，但要求她去做的事，她总能完成的很好，有很好的审美观，也与大家做出来的东西不太一样，不过个人还是比较腼腆，不擅长说话，不过似乎也说得过去。</li>
<li>其它的我也不多说了，很欣慰看到有的女生会装机了，会重装系统了，这种大胆的尝试都是非常有必要的，毕竟你比别人多了一项技能。</li>
</ol>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>催催催还是没有用的，只有自己即将毕业的时候，后悔大学没能干成什么事，就像我姐，大学里还是天天拿奖学金，但是出了社会才知道险恶，从金融业毕业，你没有实践能力，最后还不是只能当当柜员，帮银行拉点钱，比不了外面有钱的人的，只有自己掌握了足够的技术，别人才会要你，甚至花钱买你。</p>
<img src="/img/2017-12-13-1.jpg" class="">

]]></content>
      <categories>
        <category>日志</category>
        <category>软文</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>single-transition-timing-function-单个过渡式时序函数</title>
    <url>/2017/11/06/single-transition-timing-function-%E5%8D%95%E4%B8%AA%E8%BF%87%E6%B8%A1%E5%BC%8F%E6%97%B6%E5%BA%8F%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/single-transition-timing-function" target="_blank" rel="noopener">引用英译<single-transition-timing-function></a></p>
</blockquote>
<p>这个单调式时序过渡函数是一种 CSS <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Types" target="_blank" rel="noopener">数据类型</a>，用于表示在整个一维动画期间，相应的值变化多快的数学函数。可以让你在整个持续时间内通过建立各种不同的数学函数来控制数值的速度。</p>
<p>“平滑”定时功能通常被称为 easing 函数。 他们将时间比率与输出比率相关联，均表示为<Number>。 对于这些值，0.0代表初始状态，1.0代表最终状态。</p>
<a id="more"></a>
<img src="https://developer.mozilla.org/files/3434/TF_with_output_gt_than_1.png" class="">
<img src="https://developer.mozilla.org/files/3435/TF_with_output_gt_than_1_clipped.png" class="">

<p>根据所使用的具体功能，在动画过程中，计算的输出有时可能会增大到大于1.0或小于0.0。 这会导致动画比最终状态更远，然后返回。 对于某些属性，如左或右，这会产生一种“弹跳”效果。</p>
<p>但是，某些属性会超出允许的范围限制输出。 例如，大于255或小于0的颜色分量将被剪裁到最接近的允许值（分别为255和0）。 一些 cubic-bezier()  曲线显示此属性。</p>
<h1 id="Timing-functions"><a href="#Timing-functions" class="headerlink" title="Timing functions"></a>Timing functions</h1><p>CSS支持两种定时功能：作为函数的三次贝塞尔曲线的子集，以及阶梯函数。 这些函数中最有用的是给出一个关键字，使他们可以很容易地引用。</p>
<h2 id="The-cubic-bezier-class-of-timing-functions"><a href="#The-cubic-bezier-class-of-timing-functions" class="headerlink" title="The cubic-bezier() class of timing functions"></a>The cubic-bezier() class of timing functions</h2><img src="https://developer.mozilla.org/files/3433/cubic-bezier,%20example.png" class="">

<p>cubic-bezier() 函数表示法定义了一个三次贝塞尔曲线。 如这些曲线是连续的，它们通常用于平滑向下的开始和动画的端，因此有时被称为缓和功能。</p>
<p>三次贝塞尔曲线由四个点P0，P1，P2和P3限定。 P0和P3是曲线的开始和结束，在CSS中，这些点是固定的，因为坐标是比率（横坐标是时间的比率，纵坐标是输出范围的比率）。 P0为（0,0），表示初始时间和初始状态，P3为（1,1），表示最终时间和最终状态。</p>
<p>不是所有的三次贝塞尔曲线适合作为计时功能，因为不是所有的数学函数; 即对于给定的横坐标具有零个或一个值的曲线。 与P0和P3固定由CSS如所定义的，三次贝塞尔曲线是一个函数，因此是有效的，当且仅当P1和P2的横轴都在[0，1]的范围内。</p>
<p>P1或P2纵坐标在[0,1]范围以外的三次贝塞尔曲线可能会产生弹跳效果。</p>
<p>当你指定一个无效的三次贝塞尔曲线时，CSS会忽略整个属性。</p>
<p>Syntax</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cubic-bezier(x1, y1, x2, y2)</span><br></pre></td></tr></table></figure>

<p><strong>x1, y1, x2, y2</strong></p>
<p><number>值代表横坐标，P1和P2点的纵坐标定义三次Bézier曲线。 x1和x2必须在[0，1]范围内，否则该值无效。</p>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>These cubic Bézier curves are valid for use in CSS :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The canonical Bézier curve with four &lt;number&gt; in the [0,1] range. */</span></span><br><span class="line">cubic-bezier(<span class="number">0.1</span>, <span class="number">0.7</span>, <span class="number">1.0</span>, <span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Using &lt;integer&gt; is valid as any &lt;integer&gt; is also a &lt;number&gt;. */</span></span><br><span class="line">cubic-bezier(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Negative values for ordinates are valid, leading to bouncing effects.*/</span></span><br><span class="line">cubic-bezier(<span class="number">0.1</span>, <span class="number">-0.6</span>, <span class="number">0.2</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Values &gt; 1.0 for ordinates are also valid. */</span></span><br><span class="line">cubic-bezier(<span class="number">0</span>, <span class="number">1.1</span>, <span class="number">0.8</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>These cubic Bézier curves definitions are invalid :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Though the animated output type may be a color, </span></span><br><span class="line"><span class="comment">   Bézier curves work w/ numerical ratios.*/</span></span><br><span class="line">cubic-bezier(<span class="number">0.1</span>, red, <span class="number">1.0</span>, green)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Abscissas must be in the [0, 1] range or </span></span><br><span class="line"><span class="comment">   the curve is not a function of time. */</span></span><br><span class="line">cubic-bezier(<span class="number">2.45</span>, <span class="number">0.6</span>, <span class="number">4</span>, <span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The two points must be defined, there is no default value. */</span></span><br><span class="line">cubic-bezier(<span class="number">0.3</span>, <span class="number">2.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Abscissas must be in the [0, 1] range or </span></span><br><span class="line"><span class="comment">   the curve is not a function of time. */</span></span><br><span class="line">cubic-bezier(<span class="number">-1.9</span>, <span class="number">0.3</span>, <span class="number">-0.2</span>, <span class="number">2.1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="The-steps-class-of-timing-functions"><a href="#The-steps-class-of-timing-functions" class="headerlink" title="The steps() class of timing functions"></a>The steps() class of timing functions</h2><p>steps() 函数表示法定义了一个step函数，以等距离的步骤分割输出值的域。这个阶梯函数的子类有时也被称为阶梯函数。</p>
<img src="https://developer.mozilla.org/files/3436/steps(2,start).png" class="" title="steps(2, start)">

<img src="https://developer.mozilla.org/files/3437/steps(4,end).png" class="" title="steps(4, end)">

<p><strong>Syntax</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">steps(number_of_steps, direction)</span><br></pre></td></tr></table></figure>

<p>where:</p>
<p><code>number_of_steps</code></p>
<p>是一个严格的正数&lt;整数&gt;，表示构成步进函数的等距踏板的数量。</p>
<p><code>direction</code></p>
<p>是一个关键字，指示函数是左连续的还是右连续的：<br>start表示一个左连续函数，所以动画开始的时候是第一步;<br>end表示一个右连续函数，以便动画结束时发生最后一步。<br>结束是默认的。</p>
<h3 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h3><p>These timing functions are valid :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* There is 5 treads, the last one happens </span></span><br><span class="line"><span class="comment">   right before the end of the animation. */</span></span><br><span class="line">steps(<span class="number">5</span>, end)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A two-step staircase, the first one happening </span></span><br><span class="line"><span class="comment">   at the start of the animation. */</span></span><br><span class="line">steps(<span class="number">2</span>, start)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The second parameter is optional. */</span></span><br><span class="line">steps(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>These timing function are invalid :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The first parameter must be an &lt;integer&gt; and </span></span><br><span class="line"><span class="comment">   cannot be a real value, even if it is equal to one. */</span></span><br><span class="line">steps(<span class="number">2.0</span>, end)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The amount of steps must be non-negative. */</span></span><br><span class="line">steps(<span class="number">-3</span>, start)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There must be at least one step.*/</span></span><br><span class="line">steps(<span class="number">0</span>, end)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>transition</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>前端路一步步走，重新再来</title>
    <url>/2017/10/23/%E5%89%8D%E7%AB%AF%E8%B7%AF%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%B5%B0%EF%BC%8C%E9%87%8D%E6%96%B0%E5%86%8D%E6%9D%A5/</url>
    <content><![CDATA[<blockquote>
<p>目录就不写了，左边菜单有锚链接</p>
</blockquote>
<h1 id="为什么要写这篇文章"><a href="#为什么要写这篇文章" class="headerlink" title="为什么要写这篇文章"></a>为什么要写这篇文章</h1><p>是因为好几次可能遇到了问题的瓶颈了，虽然还是解决了，但是仍旧不懂其原理，大多也只是百度寻求出的答案，所以感觉自己可以学的更好但是仍有不足，对深层次的地方尚未了解的透。</p>
<p>其二，最近看到一张图，可能也是玩笑吧，不过还是体会到了自己的不足。这张图大致说的就是：“如今的程序员并不是想象中收入很低的群体，收入超过3W/Mon才能真正说为程序员，而那些3W以内的只是自称是程序员的码农而已。。。” 看着自己收获着仅有3k的工资，想想也是，作为一个实习生差不多了。不过再仔细想想，还是觉得自己掌握的也就那几部分，看看别人潜心研究的视频，拿别人的工具做做自己的项目，不敢拿一些star量少的框架，害怕找不到问题的答案，因为自己看不懂源代码，或者没有看源码的经验，害怕浪费太多时间。所有的所有都体现着自己能力不足，需要握紧基础的迫切。<br> <a id="more"></a><br>其三，虽然现在已经在初创公司工作一个月了，我并不认为在一些教育工作，外包公司工作，实习会比现在更好，我更感觉那些公司更会像人力的压榨机，或者任由你不管不问，初创公司至少会有一点比他们好点，人少，关怀就多一些，项目不重而且会有时间来教导你。我觉得是今后如果有些毕业生可以选择的方向。而且又CTO带着你，4年的工作经验，几乎你会的，他都会，所以根本不用担心。</p>
<h1 id="这个月需要完成的计划"><a href="#这个月需要完成的计划" class="headerlink" title="这个月需要完成的计划"></a>这个月需要完成的计划</h1><p>其实这一部分，我已经写在提醒事项里了，不过计划赶不上变化，日日如此。也顺便列出一些理由</p>
<ol>
<li><p>好好学透 <code>ES6</code> 这个语法和知识点<br>不管是 <code>ES6</code> 还是 <code>ES5</code> 甚至 <code>ES7</code> 过去 <code>JS</code> 所犯的错误和它如今或者今后要去做的任务都大致写在了里面，从5开始将浏览器的规范合为一体，到6想要将从后端语言中抢来一定的席位，到7开始大量关切语法糖和必要的修饰，这些都可以看出 <code>JS</code> 这门语言发展有多迅速，蔓延地有多深。最直接可以看出地就是 <code>GitHub</code> 上 <code>JS</code> 开源量年年领先于其它语言。所以学好这门语言的基础就是好好利用好新语法，新写法。</p>
</li>
<li><p><code>HTML</code> 中尤其是 <code>H5</code> 中最新的 <code>DOM API</code><br>可能之前有很好的替代方案，比如 flash 做一些视频， flash 做摄像头的获取，JQ 中对 DOM 的操作等等。<br>不过随着前端web浏览器几乎每月的更新，Chrome 更是每周的更新，好用的API不为我们所知，可以他们的确是可以用了，而且是原生的，不用加入JQ等一些第三方的插件了。所以好好并且细细地学一遍DOM API还是很有必要地。</p>
</li>
<li><p>CSS CSS3 动画，关键帧，变换的使用<br>真的，如果要让你的见面时刻展示给用户最美的体验，视频插入之外，CSS动画毋庸置疑是必须要了解和掌握的。特别是利用一些第三方的引入，可能会让你更加了解动画的整个过程。</p>
</li>
<li><p>Canvas WebGL来开发3D或者2D在某些地方是效率是绝对比CSS3要高的，而且，在VR或者AR上，他们更具有优势。希望还是能学到这儿。</p>
</li>
<li><p>WebRTC 实时语音的功能，这里不太了解，暂且放这儿</p>
</li>
<li><p>WebSocket 浏览器与服务器端的双向通信</p>
</li>
</ol>
<p>还有很多技术真的，很多😭</p>
<h1 id="将来可能要接触的方向"><a href="#将来可能要接触的方向" class="headerlink" title="将来可能要接触的方向"></a>将来可能要接触的方向</h1><ol>
<li><p>React 的开发<br>说真的，虽然Vue还是依然的火热，但是React的想法真的比Vue更加特别与奇特，所以等我攒了钱买了台好点的Mac Pro笔记本，我必将细细品味真正的前端。</p>
</li>
<li><p>Meteor 的开发<br>与React 一样，几近全栈的开发的一门框架，最近才了解到，虽然录得那个视频是15年录得好似，不过这个框架人具有不少令人尝试的勇气。</p>
</li>
</ol>
<p>其它就不多说了，还是走一步是一步，万一又出来一个比较叼的语言或框架呢？</p>
<h1 id="补充-TypeScript"><a href="#补充-TypeScript" class="headerlink" title="补充 TypeScript"></a>补充 TypeScript</h1><p>TypeScript有着 JS 的优点，并补足了 JS 不严谨的缺点，可以适当学习😊</p>
]]></content>
      <categories>
        <category>日志</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 与远程仓库(Remote)的那些事(坑)</title>
    <url>/2017/10/13/Git-%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93-Remote-%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B-%E5%9D%91/</url>
    <content><![CDATA[<blockquote>
<p>参考：（无）</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好久没有更新博客了，自上次9月25日更新了一些数据结构的笔记以后，去忙别的事情了，原因的话，应该都懂。工作啦，还是学习，买手机等等，总之还是在规划自己的学习路线，时刻更新下，毕竟计划赶不上变化。<br>突然写这篇文章的原因有很多，有惠阳学弟向我要一些文章博客，还要我的博客…我就突然想起来了（我他妈博客几年没更新了，在我脑中），还有就是最近项目都有用到 <code>Git</code> 这个版本管理工具，虽然之前我经常用，不过自己平时与工作的情景毕竟已经不太一样了，除了要知道最基本的 <code>git init</code> , <code>git add -A</code>, <code>git commit -m &quot;your commit&quot;</code>, <code>git push</code> 等等，最重要的是你的远程管理仓库是不一定只有一个，比如我们公司要用的是 <a href="https://gitlab.com" target="_blank" rel="noopener">gitlab</a> 这完全与 <a href="https://github.com" target="_blank" rel="noopener">github</a> 不是同一个远程库，你得学会怎么同时管理多个远程库，而且里边有许多坑（Hole），这些坑你得自己找，网上是找不到的，毕竟现在人工智能的范围未能达到如此地步（我会在下文介绍一些我遇到坑）。<br> <a id="more"></a></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li>怎么将本地库与远程库关联</li>
<li>使用ssh-key去验证自己的身份</li>
<li>多远程仓库的管理与配置</li>
<li>一个巨大的坑（详细介绍）</li>
</ul>
<h1 id="怎么将本地库与远程库关联"><a href="#怎么将本地库与远程库关联" class="headerlink" title="怎么将本地库与远程库关联"></a>怎么将本地库与远程库关联</h1><img src="/img/2017-10-13-1.png" class="" title="图1">
<p>其实 <code>图1</code> 已经给出明确的答案了，如果需要详细的网页可以<a href="https://github.com/Lanseria/e" target="_blank" rel="noopener">点击这里</a><br>这张图中第二部分就是给出的是，如果你已经先在本地有 <code>Git</code> 仓库了，<br>当然注意，这个仓库一定是已经 <code>git init</code> 过的，或者说是 <code>git clone</code> 过的，不能你自己以为就是以为。<br>然后，执行这句命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com:[yourusername]/[repo].git</span><br></pre></td></tr></table></figure>
<p><code>yourusername</code> 是你在github或者其它刚刚建立的远程仓库的使用者，也就是你自己的昵称<br><code>repo</code> 是你建立的仓库名字，这步一定是最前的，不然你怎么跟本地库关联。</p>
<p>最后将本地库推送到远程库<br>执行这句 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>意思就是 推送 到 <code>origin</code> (没错这就是刚刚指代的你的远程库代称) <code>master</code> 就是远程库的 <code>master</code> 分支</p>
<h1 id="使用ssh-key去验证自己的身份"><a href="#使用ssh-key去验证自己的身份" class="headerlink" title="使用ssh-key去验证自己的身份"></a>使用ssh-key去验证自己的身份</h1><p>可能看完上一章的童鞋会问，ssh-key是干吗用的，不是只要知道 <code>push</code> , <code>pull</code>, <code>clone</code> 命令就可以了吗？<br>看样子好像，似的。但是又不是<br>你可以自己看看 <code>图1</code> 的截图，和刚才添加命令中的地址信息，你知道 <code>https://github.com</code> 是什么意思吗？<br>我们放大 <code>图1</code> 的细节</p>
<img src="/img/2017-10-13-2.png" class="" title="图2">
<p>有 <code>https</code> 和 <code>ssh</code> 选项，而且你点击哪个，他的地址就会发生改变<br>ssh: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:Lanseria/e.git<br>https: <a href="https://github.com/Lanseria/e.git" target="_blank" rel="noopener">https://github.com/Lanseria/e.git</a><br>这两种加密方式都是对你代码在 <code>tcp</code> 的传输中，不会被他人截取，所以不要想为什么没有 <code>http</code> 等等问题啦<br>我说说这两者的区别吧<br> <code>https</code> 就像你登陆网站是去输入账户和密码来验证你的身份合法<br>而 <code>ssh</code> 则采用流行于 <code>linux</code> 的 <code>ssh</code> 登陆的加密方式去管理你的账户<br>所以两者的便捷性不言而喻<br>最大的体验就是<br>https 每次重启计算机，你下次去 push , pull , clone 都需要你重新输入密码<br>而 ssh 就像你和远程的仓库， 比如 github 已经互相确认了对方的信息，只要双方的加密过的 key 正确，我就相信你</p>
<p>所以，入门者可以用用 https 但是， 如果你用到工作中， ssh 必然会方便很多</p>
<h2 id="如何配置"><a href="#如何配置" class="headerlink" title="如何配置"></a>如何配置</h2><p>放一个官方的地址<br><a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank" rel="noopener">https://help.github.com/articles/connecting-to-github-with-ssh/</a><br>你们应该不会打我吧<br>不会百度嘛，很轻松的事<br>我来列举下期间会用到的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br><span class="line">// 这里 -b 4096 可以不加，邮箱填写自己的注册时的帮你邮箱</span><br><span class="line">Enter a file in which to save the key (/c/Users/you/.ssh/id_rsa):[Press enter]</span><br><span class="line">// 这可能会弹出这个，意思是这个key会保存在这里，并命名为id_rsa 你可以修改他的名字，不过建议如果你不是多仓库的话还是不要改了</span><br><span class="line">Enter passphrase (empty for no passphrase): [Type a passphrase]</span><br><span class="line">Enter same passphrase again: [Type passphrase again]</span><br><span class="line">// 这两个是加密的密码，听起来很绕，但直接回车，设置为空就可以了，两下回车，第二个是comfirm的意思</span><br></pre></td></tr></table></figure>
<p>最后就生成了<br>你用编辑器，打开当个目录（/c/Users/you/.ssh/）的中*.pub的文件，将里边的字符复制出来<br>放到github中ssh管理中，添加即可</p>
<h1 id="多远程仓库的管理与配置"><a href="#多远程仓库的管理与配置" class="headerlink" title="多远程仓库的管理与配置"></a>多远程仓库的管理与配置</h1><p>来了，这个的前序章节<br>让我假装新手，百度一下<br>就这篇文章了吧<a href="https://my.oschina.net/guanyue/blog/485918" target="_blank" rel="noopener">https://my.oschina.net/guanyue/blog/485918</a><br>它说（/c/Users/you/.ssh/）下添加config配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host gitlab.xxx.com ##可以随意命名，链接时使用这个名字    </span><br><span class="line">HostName gitlab.xxx.com    </span><br><span class="line">User git    </span><br><span class="line">Port 22    </span><br><span class="line">IdentityFile ~/.ssh/id_rsa_second</span><br></pre></td></tr></table></figure>
<p>没了</p>
<h1 id="一个巨大的坑（详细介绍）"><a href="#一个巨大的坑（详细介绍）" class="headerlink" title="一个巨大的坑（详细介绍）"></a>一个巨大的坑（详细介绍）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#github HostName 和Host一定要一样，不能随便取，为什么？自己找</span><br><span class="line">Host github.com </span><br><span class="line">    HostName github.com</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_home</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    User youreamil@qq.com</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>ssh</tag>
        <tag>hole</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法笔记1--绪论</title>
    <url>/2017/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B01-%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<blockquote>
<p>参考清华大学数据结构课程<a href="http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240184+sp/courseware/a8c755dbb15b4bce9165d4df80f6485a/b712b0a3477f4e7ea99d05223c23ce4b/" target="_blank" rel="noopener">链接</a></p>
</blockquote>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><ul>
<li>C++：类，继承，重载，重写，虚方法，模板</li>
<li>离散：集合，偏序列，良序，数学归纳法，级数，递归，递推</li>
<li>概率基础：随机分布，概率，伯努利实验，数学期望，期望率，线率</li>
</ul>
<h1 id="一、计算与算法"><a href="#一、计算与算法" class="headerlink" title="一、计算与算法"></a>一、计算与算法</h1><p>1.计算机的本质就是计算，寻找对象的规律，并从中找到技巧。计算的目标是高效，低耗。<br>计算=信息处理<br>2.算法就是借助一定的工具，在一定的规则下，以明确而机械的形式来进行的计算。<br>计算模型=计算机=信息处理工具<br>3.算法的主要特性：<br>  输入，输出</p>
<ul>
<li>正确性：算法能够正确地解决问题</li>
<li>确定性：所有步骤均由基本的操作组成</li>
<li>可行性：基本操作均能够实现</li>
<li>有穷性：所有操作在时间的允许范围内<br>课程中主要讲解了一种 <code>Hailstone</code> 的一个例子<br>但是 <code>Hailstone</code> 目前还未确认是否有穷</li>
</ul>
<p>所以程序不一定是一个算法<br> <a id="more"></a><br>4.好的算法<br>正确：<br>符合语法，能够编译，链接<br>能够正确处理简单的输入<br>能够正确处理大规模的数据（一般性，退化的，任意的合法的输入）<br>健壮：<br>能够辨别不合法的输入并做适当的处理，而不至于非正常退出<br>可读性好：<br>要有结构化+准确的命名+注释……<br>效率（⚠）：速度尽可能快，存储空间尽可能少</p>
<p>Algorithms + Data Structures = Programs</p>
<p>(Algorithms + Data Structures) * Efficienty = Compution</p>
<h1 id="二、计算模型"><a href="#二、计算模型" class="headerlink" title="二、计算模型"></a>二、计算模型</h1><p>性能测度</p>
<blockquote>
<p>To measure is to know. If you can not measure it, you can not improve it –Lord kelvin</p>
</blockquote>
<p>不同的 <code>DSA</code> 这里简称 <code>(Data Structures Algorithms)</code> 的性能有好坏优劣之分，所以我们需要度量。</p>
<p>1.引入理想，统一，分层次的尺度<br>2.运用尺度，以测量 <code>DSA</code> 的性能</p>
<p>算法分析：<br>1.正确性<br>2.成本（运行的时间有+空间）如何度量，如何比较</p>
<p>一般的计算模型有图灵模型与RAM模型，它们均将算法的运算时间转换成算法执行的基本操作次数。</p>
<h1 id="三-图灵机模型"><a href="#三-图灵机模型" class="headerlink" title="三. 图灵机模型"></a>三. 图灵机模型</h1><p>1.图灵机的三个组成要件<br>有限长的字母表： cell中存储的内容<br>读写头：指示当前位置，可读可写。<br>状态表：当前读写头的状态</p>
<p>2.图灵机状态转换过程 transform(q,c;f,L/R,p)<br>q：当前状态<br>c：读写头所指cell当前的内容<br>f：读写头所指cell改写的内容<br>L/R：向左/右移位<br>p：读写头转换后的状态</p>
<h1 id="四-RAM-模型"><a href="#四-RAM-模型" class="headerlink" title="四. RAM 模型"></a>四. RAM 模型</h1><p>1.与图灵机类似，均假设有无限空间<br>2.由一系列顺序编号寄存器组成，但总数无限<br>3.算法所运行的时间转换成算法运算时的次数</p>
<h1 id="五、大O记号"><a href="#五、大O记号" class="headerlink" title="五、大O记号"></a>五、大O记号</h1><blockquote>
<p>Mathematics is more in need of good notations than of new theorems. – Alan Turing</p>
</blockquote>
<p>考虑长远，主流方向</p>
<p>渐近分析：大O记号<br>Asymptotic analysis:<br>当 n &gt;&gt; 2 后，对于规模为 n 的输入，算法<br>1.需要执行的基本操作次数：T(n)<br>2.需要占用的存储单元数：S(n)</p>
<p>1.大O记号(big-O notation)<br>T(n) = O(f(n))<br>f(n)为一个函数。当c &gt; 0, T(n) &lt; c ∗ f(n)，即大O记号表示T(n)的一个上界，其性质为：<br>O(n)=O(c∗n)<br>O(n2+n)=O(n2)</p>
<img src="/img/2017-09-26-1.png" class="">

<p>2.大Ω的定义：T(n)=Ω(f(n)) ,f(n)为一个函数。当c&gt;0,T(n)&gt;c∗f(n)，即大O记号表示T(n)的一个下界。</p>
<p>3.大Θ的定义：T(n)=Θ(f(n)) ,f(n)为一个函数。当c1&gt;c2&gt;0，c1∗f(n)&gt;T(n)&gt;c2∗f(n)，即大O记号表示T(n)的一个区间。</p>
<h1 id="六、大O记号下的刻度"><a href="#六、大O记号下的刻度" class="headerlink" title="六、大O记号下的刻度"></a>六、大O记号下的刻度</h1><p>1.常数复杂度(constant function)<br>O(1)<br>2 = 2017 = 2017 * 2017 = 2017^2017 //含RAM各基本操作<br>这类算法的效率最高<br>不含转向（循环，调用，递归）<br>必须顺序执行<br>2.对数类：O(logcn)与常底数、常数次幂无关，复杂度接近常数，有效。</p>
<img src="/img/2017-09-26-2.png" class="">
<p>3.多项式：O(nc)<br>4.线性：O(n)</p>
<img src="/img/2017-09-26-3.png" class="">
<p>5.指数：cn=O(2n)任何c均可。成本增长极快，不是有效的。</p>
<img src="/img/2017-09-26-4.png" class="">

<h1 id="七、算法分析"><a href="#七、算法分析" class="headerlink" title="七、算法分析"></a>七、算法分析</h1><p>两个主要任务 = 正确性（不变性 * 单调性) + 复杂度</p>
<p>复杂度的分析主要方法</p>
<p>迭代：级数求和<br>递归：递归跟踪 + 递推方程<br>猜测 + 验证</p>
<p>1.级数</p>
<img src="/img/2017-09-26-5.png" class="">
<img src="/img/2017-09-26-6.png" class="">
<blockquote>
<p>Concrete Mathematics </p>
</blockquote>
<p>2.循环与级数</p>
<img src="/img/2017-09-26-7.png" class="">]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>面试</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript类数组转化为数组</title>
    <url>/2017/08/11/javascript%E7%B1%BB%E6%95%B0%E7%BB%84%E4%B8%8E%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<blockquote>
<p>刚认识到这个知识点应该不晚吧~ 想想面试应该也会考到这类题，所以拿出来说说。<br>不过前天的面试估计没过，还是挺惋惜的，主要还是我态度不怎样，一是觉得是培训公司（这么大的一个招牌挂在上面，心里看上去就挺不爽的）无所谓了。二来还是觉得太急，想晚点找个好点的工作，这次也就当 <code>test</code> 吧。<br>不过面试中，我以为她都懂（就是一个正式的懂前端的人），现在想想，她就是拿着答案对我的口题，对我的笔试题，我想想就气。不知道技术的人拿着那种答案有什么用，只会一个劲儿的点点头，CTMD！（早知道，我一个劲的吹逼就行了，浪费我大一堆口舌 🙄）</p>
</blockquote>
<p>切入正题，什么是类数组，它在我们频繁的操作中有什么关系，为什么要用到数组？<br> <a id="more"></a><br>其实，一切都要从对象还是讲起，毕竟JavaScript中任何类型都是基于一个对象<br>有一篇国外文章可能对对象，数组，讲得更好，本篇文章会部分引用他的案例<a href="http://www.nfriedly.com/techblog/2009/06/advanced-javascript-objects-arrays-and-array-like-objects/" target="_blank" rel="noopener">advanced-javascript-objects-arrays-and-array-like-objects</a></p>
<h1 id="什么是类数组"><a href="#什么是类数组" class="headerlink" title="什么是类数组"></a>什么是类数组</h1><blockquote>
<p>我这里说的类数组是广义上的类数组，其解释就类似于能通过<code>[].prototype.slice.call(ARRAYLIKE)</code>转化为数组的形式。<br>到目前为止，我用这类类数组转化为数组的方式，用在了许多地方</p>
</blockquote>
<ol>
<li><code>Buffer</code> 对象，这是有点让我不解的地方</li>
<li><code>DOM</code> 获取的同 <code>className</code> 的 <code>DOM</code> 节点群的类数组，当然还有同 <code>tagName</code></li>
<li>最后一种就是大家都知道的典型例子， <code>arguments</code><br>所以呢，除了第一个，经常用js写前端的你，应该会碰到下面两种的转化</li>
</ol>
<h1 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h1><p>什么是数组，也就是为了讲明什么要将类数组转化为数组的原因<br>数组有很多好处，但这些好处都一并归纳在了这个数组对象所定义的方法里<br>比如说，堆栈队列的操作，pop(),push(),shift(),<br>排序的操作，sort()<br>还有很多方法可以使用，这里也就不在一一列举<br>数组与类数组有两点相似</p>
<ol>
<li>都内部都自己的子元素</li>
<li>都有定义的长度</li>
</ol>
<p>但是长度这里也比较奇怪的是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"cat"</span>; <span class="comment">// this adds to the array</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"mouse"</span>; <span class="comment">// this adds to the array</span></span><br><span class="line">arr.length; <span class="comment">// returns 2</span></span><br><span class="line"></span><br><span class="line">arr[<span class="string">"favoriteFood"</span>] = <span class="string">"pizza"</span>; <span class="comment">// this DOES NOT add to the array. Setting a string parameter adds to the underlying object</span></span><br><span class="line">arr.length; <span class="comment">// returns 2, not 3</span></span><br></pre></td></tr></table></figure>
<p>The length property is only modified when you add an item to the array, not the underlying object.<br>长度这个属性，只会在你添加或删除一个元素的时候与触发，当你自己定义它（这个数组）的属性时，它是不会增加的（就如同又来了一个<code>length2</code>属性）。</p>
<p>而且，当你直接定义一个比较远的数组索引时，比如100，这时，length总会比其索引值大1，而且不会报错，然后，中间的其它值会暂时的定义为undefined，以便填充</p>
<h1 id="坑-Gotchas"><a href="#坑-Gotchas" class="headerlink" title="坑 Gotchas"></a>坑 Gotchas</h1><blockquote>
<p>其实这篇文章已经讲完了，不过还是要总结下，这期间遇到的<code>坑 Gotchas</code></p>
</blockquote>
<ol>
<li>DOM获取的class节点还是tagname节点都是一群对象组成一个类数组</li>
<li>最好使用一些库函数，such as lodash.js 将这些类数组进行转化</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>前端</tag>
        <tag>call</tag>
        <tag>数组</tag>
        <tag>类数组</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>学习jQuery源代码之三>>对象</title>
    <url>/2017/07/28/%E5%AD%A6%E4%B9%A0jQuery%E6%BA%90%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%89-%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<blockquote>
<p>此系列文章大致参考 <a href="http://www.imooc.com/learn/172" target="_blank" rel="noopener">http://www.imooc.com/learn/172</a></p>
</blockquote>
<h1 id="类与函数"><a href="#类与函数" class="headerlink" title="类与函数"></a>类与函数</h1><p>面向对象(OOP)的语言都有一个特点，它们都会有类的这一概念，通过类可以抽象出创建具体相同方法与属性的对象。但是ECMAScript中是没有类的概念的，因此它的对象与基于类的语言如java的定义是有所不同的。</p>
<p>在 JavaScript 世界中函数作为“一等公民”，它不仅拥有一切传统函数的使用方式（声明和调用），而且可以做到像简单值一样赋值、传参、返回，这样的函数也称之为第一级函数。不仅如此，而且还可以通过操作符 new 来充当类的构造器。</p>
<p>函数在充当类的构造器时，原型prototype是一个重要的概念。prototype是构造函数的一个属性, 该属性指向一个对象。而这个对象将作为该构造函数所创建的所有实例的基引用(base reference), 可以把对象的基引用想像成一个自动创建的隐藏属性。 当访问对象的一个属性时, 首先查找对象本身, 找到则返回；若不, 则查找基引用指向的对象的属性(如果还找不到实际上还会沿着原型链向上查找,  直至到根)。 只要没有被覆盖的话, 对象原型的属性就能在所有的实例中找到。</p>
 <a id="more"></a>

<p>其实这也就是JavaScript的剖析了，与其它语言不一样的地方就是类的构造不同，JavaScript没有类，即时是在es6中定义了class这个新特性，但它原则上还是认为function是第一公民，一切类的继承在JavaScript中都可以看作是一条条函数的原型链，通过scope将对应的属性找到。</p>
<p>jQuery的对象构造也是如此，虽然有两种写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类一：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajQuery</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = <span class="string">'jQuery'</span>;</span><br><span class="line">	<span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ajQuery();</span><br><span class="line"><span class="comment">// chrome查看</span></span><br><span class="line">ajQuery</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajQuery</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = <span class="string">'jQuery'</span>;</span><br><span class="line">	<span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/img/2017-07-28-1.png" class="">
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bjQuery</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = <span class="string">'jQuery'</span>;</span><br><span class="line">&#125;</span><br><span class="line">bjQuery.prototype = &#123;</span><br><span class="line">	sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> bjQuery()</span><br><span class="line">bjQuery</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bjQuery</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = <span class="string">'jQuery'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/img/2017-07-28-2.png" class="">
<p>但是很明显第一种的写法在性能上更有优势，因为函数都是一样的，为什么要重复去申明呢？<br>jQuery的大致写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jQuery的写法</span></span><br><span class="line"><span class="keyword">var</span> $jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> $jQuery.fn.init(selector, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$jQuery.fn = $jQuery.prototype = &#123;</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'aaron'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">constructor</span>: $jQuery</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var $a = $jQuery();</span><br><span class="line"></span><br><span class="line">show('$jQuery的调用')</span><br><span class="line">show($a);</span><br></pre></td></tr></table></figure>
<p>虽然ajQuery使用了类二的原型结构，性能上有优化，但与实际中的jQuery还是有很多不一样的。<br>☑ 没有采用new操作符<br>☑ return返回的是一个通过new出来的的对象</p>
<img src="/img/2017-07-28-3.png" class="">
<img src="/img/2017-07-28-4.png" class="">
<img src="/img/2017-07-28-5.png" class="">
<blockquote>
<p><strong>提示: 如果实在听不懂，可以看看大神写的一个比较有趣的jQuery讲解，<a href="http://www.zhangxinxu.com/wordpress/2013/07/jquery-%E5%8E%9F%E7%90%86-%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">张大神-jQuery诞生记-原理与机制</a></strong></p>
</blockquote>
<p>里面也有许多点可以提一提，是个不错的方案，以后可以用在一些模块的写法上。<br>比如在重复获取 ID 上，可以偷点懒</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $ = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> $.fn(selector, context);</span><br><span class="line">&#125;;</span><br><span class="line">$.fn = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.init(selector, context);</span><br><span class="line">&#125;;</span><br><span class="line">$.fn.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nodeList = (context || <span class="built_in">document</span>).querySelectorAll(selector);</span><br><span class="line">  <span class="keyword">this</span>.length = nodeList.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++)&#123;</span><br><span class="line">    <span class="keyword">this</span>[i] = nodeList[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">$.fn.prototype.each = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>, length = <span class="keyword">this</span>.length;</span><br><span class="line">  <span class="keyword">for</span>(; i &lt; length; i++)&#123;</span><br><span class="line">    fn.call(<span class="keyword">this</span>[i], i, <span class="keyword">this</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line">$.fn.prototype.hide = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.style.display = <span class="string">"none"</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.style.display = <span class="string">"none"</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>`</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>前端</tag>
        <tag>jquery</tag>
        <tag>prototype</tag>
        <tag>object</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>算法，Javascript也有算法(2)</title>
    <url>/2017/07/25/%E7%AE%97%E6%B3%95%EF%BC%8CJavascript%E4%B9%9F%E6%9C%89%E7%AE%97%E6%B3%95-2/</url>
    <content><![CDATA[<blockquote>
<p><strong>提示</strong> 这系列文章我会时常更新，时间也会相对应的更新，如果对前文想略过，可以直接点击这里<a href="/2017/07/23/算法，Javascript也有算法/#今天来讲什么的？我只能说小算法">今天来讲什么的？我只能说小算法</a></p>
</blockquote>
<p>今天算是比较熟悉面试（牛客网）中的算法流程，虽然 <code>node v0.12</code> 版本的很恶心，但还是可以用的<br> <a id="more"></a></p>
<h2 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h2><p>参考：<a href="http://www.thatjsdude.com/interview/linkedList.html" target="_blank" rel="noopener">http://www.thatjsdude.com/interview/linkedList.html</a></p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。</p>
<h3 id="单链表（单向链表）"><a href="#单链表（单向链表）" class="headerlink" title="单链表（单向链表）"></a>单链表（单向链表）</h3><p>链表中最简单的一种是单向链表，它包含两个域，一个信息域和一个指针域。这个链接指向列表中的下一个节点，而最后一个节点则指向一个空值。</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Singly-linked-list.svg/408px-Singly-linked-list.svg.png" class="" title="一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接">
<p>任何语言都有千万种表示方式去呈现链表，这里我写出两种，一种是在参考上的，一种是参考leetcode上的链表<br>One:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinkedList.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> node = &#123;</span><br><span class="line">    value: val,</span><br><span class="line">    next: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">this</span>.head)&#123;</span><br><span class="line">    <span class="keyword">this</span>.head = node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    current = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span>(current.next)&#123;</span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    current.next = node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sll = <span class="keyword">new</span> LinkedList();</span><br><span class="line">sll.push(<span class="number">2</span>);</span><br><span class="line">sll.push(<span class="number">3</span>);</span><br><span class="line">sll.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sll);</span><br><span class="line"><span class="built_in">console</span>.log(sll.head);</span><br><span class="line"><span class="built_in">console</span>.log(sll.head.next);</span><br><span class="line"><span class="built_in">console</span>.log(sll.head.next.next);</span><br></pre></td></tr></table></figure>
<p>Two: </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = val;</span><br><span class="line">  <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">ListNode.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> node = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">  <span class="keyword">var</span> current = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">while</span>(current.next)&#123;</span><br><span class="line">    current = current.next</span><br><span class="line">  &#125;</span><br><span class="line">  current.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>一种更复杂的链表是“双向链表”或“双面链表”。每个节点有两个连接：一个指向前一个节点，（当此“连接”为第一个“连接”时，指向空值或者空列表）；而另一个指向下一个节点，（当此“连接”为最后一个“连接”时，指向空值或者空列表）</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5e/Doubly-linked-list.svg/610px-Doubly-linked-list.svg.png" class="" title="一个双向链表有三个整数值: 数值, 向后的节点链接, 向前的节点链接">
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyLinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  push(val) &#123;</span><br><span class="line">    <span class="keyword">var</span> head = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">var</span> current = head;</span><br><span class="line">    <span class="keyword">var</span> previous = head;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">      <span class="keyword">this</span>.head = &#123;</span><br><span class="line">        value: val,</span><br><span class="line">        previous: <span class="literal">null</span>,</span><br><span class="line">        next: <span class="literal">null</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (current &amp;&amp; current.next) &#123;</span><br><span class="line">        previous = current;</span><br><span class="line">        current = current.next;</span><br><span class="line">      &#125;</span><br><span class="line">      current.next = &#123;</span><br><span class="line">        value: val,</span><br><span class="line">        previous: current,</span><br><span class="line">        next: <span class="literal">null</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dll = <span class="keyword">new</span> DoublyLinkedList();</span><br><span class="line">dll.push(<span class="number">2</span>);</span><br><span class="line">dll.push(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dll.head.next.previous);</span><br></pre></td></tr></table></figure>
<h2 id="二、算法"><a href="#二、算法" class="headerlink" title="二、算法"></a>二、算法</h2><h3 id="1-回文数的最小个数"><a href="#1-回文数的最小个数" class="headerlink" title="1.回文数的最小个数"></a>1.回文数的最小个数</h3><p>这里我只能大致讲一下题目意思，百度也有，也是只有 <code>JavaScript</code> 做的，所以我这里把题目抄一下：</p>
<blockquote>
<p><strong>Description</strong><br>提供一个字符串 <code>s</code> ，其中每个字符都是小写字母。并提供字符串长度。<br>要求：输字符串 <code>s</code> 中元素拼凑出的回文串的最小个数。其中，每个字符只能使用一次。<br>例如： <code>s=&quot;abbaa&quot;</code> ，输出 <code>1</code> ，因为最少可以拼凑出 <code>&quot;ababa&quot;</code> 这一个回文串。<br> <code>s=&quot;abc&quot;</code> ，输出 <code>3</code> ，因为最少只能拼凑出 <code>&quot;a&quot;，&quot;b&quot;，&quot;c&quot;</code> 这三个回文串。</p>
</blockquote>
<p>其实说实话，毫无思路，因为你不可能枚举那没多种情况，在网上看到题解之后，也懂了（秒懂）。<br>因为在一个随机的字符串中，如果需要求最少的回文个数的话，只要找其中每个字母的个数就可以了，其中呢，偶数完全不需要考虑，但是奇数个是整个回文数的核心，同个字母有几个个数就有几个回文数。偶数的字母只要靠边站就行了。<br>有思路就有动力了，用一个Map就可以了，再用一个数组将Map中的值包括起来，对奇数个数进行计算，就可以得出最后的结果了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = <span class="built_in">String</span>(str);</span><br><span class="line">  <span class="keyword">if</span> (!str) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> nums = str.split(<span class="string">''</span>).reduce(<span class="function"><span class="keyword">function</span> (<span class="params">map, s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.set(s, (map.get(s) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="keyword">new</span> <span class="built_in">Map</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(nums.values()).reduce(<span class="function"><span class="keyword">function</span> (<span class="params">odd, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> !== <span class="number">0</span> ? odd + <span class="number">1</span> : odd;</span><br><span class="line">  &#125;, <span class="number">0</span>) || <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>算法</tag>
        <tag>回文数</tag>
      </tags>
  </entry>
  <entry>
    <title>算法，Javascript也有算法(1)</title>
    <url>/2017/07/23/%E7%AE%97%E6%B3%95%EF%BC%8CJavascript%E4%B9%9F%E6%9C%89%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p><strong>提示</strong> 这系列文章我会时常更新，时间也会相对应的更新，如果对前文想略过，可以直接点击这里<a href="/2017/07/23/算法，Javascript也有算法/#今天来讲什么的？我只能说小算法">今天来讲什么的？我只能说小算法</a></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在还没工作的我，对IT互联网的技术也有自己的一番认知，同时尽量把我所知道的传播给下面的学弟学妹，让她们提提力气，不要只局限于老师所教的知识就以为，以为计算机这个大专业就这么点东西。<br>虽然身在电科这个很·棒的专业，但我也在日常与室友计科软工的带领下，自己走向一条对自己适合的道路。<br>什么都会点，还是不太精，什么都做过点项目，但是成品还是有点粗糙。我的理念也不像那些呆在实验室的人一样，老师给什么，就做什么。老师提什么，我都会跟他一块去讨论，将别人的想法稍稍改变下，总的来说，使项目朝着自己所期望的做，所以一般情况下，项目转交给别人，一般就传不下去了……<br> <a id="more"></a></p>
<h1 id="废话又扯多了，算法，咳咳"><a href="#废话又扯多了，算法，咳咳" class="headerlink" title="废话又扯多了，算法，咳咳"></a>废话又扯多了，算法，咳咳</h1><p>说实话，大一参加ACM我竟然退了，现在开始想想也挺后悔的，更后悔的是还在一个现在根本不想呆的地方，浪费了我这么多时间。<br>说到ACM，难免会提到算法，可能大一的我没能认识到算法的重要性，觉得它并有没实际的优越感，就放弃了，想想很可惜的。<br>好的程序 = 优秀的算法 + 可靠的数据结构<br>万年不变的真理啊，但真正能掌握他们的人，少之又少。</p>
<h1 id="Javascript需要算法吗？"><a href="#Javascript需要算法吗？" class="headerlink" title="Javascript需要算法吗？"></a>Javascript需要算法吗？</h1><p>甚至更加简单一点的，前端需要算法吗？<br>可能很多人都会说，不就是写界面吗？还需要这么高深的算法吗？<br>对，你们所知道的前端还是过去的前端，属于设计师与代码混合的年代，而现在分工却更加的明确。前端需要更多的知识填充，而这些知识包括，websocket，tcp，http，网络，linux这些后端才会遇到的知识。所以，想当然，算法是完全有必要的。</p>
<h1 id="今天来讲什么的？我只能说小算法"><a href="#今天来讲什么的？我只能说小算法" class="headerlink" title="今天来讲什么的？我只能说小算法"></a>今天来讲什么的？我只能说小算法</h1><p>个人比较谦虚，真是不会太难的算法，所以这里只能将我了解到的算法，在这里给你们分享下，当然，介绍算法的同时不会忘记介绍JavaScript中的数据结构。</p>
<ul>
<li><p>推荐的OJ：</p>
<ul>
<li><a href="https://leetcode.com/" target="_blank" rel="noopener">LeetCode</a></li>
</ul>
</li>
<li><p>阅读推荐：</p>
<ul>
<li><a href="https://book.douban.com/subject/20432061/" target="_blank" rel="noopener">算法导论</a></li>
<li><a href="https://book.douban.com/subject/26337727/" target="_blank" rel="noopener">算法设计与分析基础</a></li>
<li><a href="https://book.douban.com/subject/26638586/" target="_blank" rel="noopener">程序员代码面试指南：IT名企算法与数据结构题目最优解</a></li>
</ul>
</li>
</ul>
<h2 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h2><p>参考：<a href="http://www.thatjsdude.com/interview/linkedList.html" target="_blank" rel="noopener">http://www.thatjsdude.com/interview/linkedList.html</a></p>
<h3 id="1-堆栈和队列"><a href="#1-堆栈和队列" class="headerlink" title="1.堆栈和队列"></a>1.堆栈和队列</h3><p>如果不是 JavaScript 的新手，应该知道JavaScript是已经自己实现了堆栈和队列。<br>你只需要简单的调用 <code>push</code> ， <code>pop</code> ， <code>shift</code> 这些操作 <code>array</code> 的函数即可。<br>不过，你甚至对C++中的优先队列有点印象的话，也有人实现了类似的原型构造，<br><a href="https://github.com/janogonzalez/priorityqueuejs/blob/master/index.js" target="_blank" rel="noopener">priorityQueueJS的简化版本</a><br>堆栈：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myStack = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">//push</span></span><br><span class="line">myStack.push(<span class="number">1</span>);</span><br><span class="line">myStack.push(<span class="number">2</span>);</span><br><span class="line">myStack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//pop</span></span><br><span class="line">myStack.pop(); <span class="comment">//3</span></span><br><span class="line">myStack.pop(); <span class="comment">//2</span></span><br><span class="line">myStack.pop(); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>队列：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myQueue = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">//push</span></span><br><span class="line">myQueue.push(<span class="number">1</span>);</span><br><span class="line">myQueue.push(<span class="number">2</span>);</span><br><span class="line">myQueue.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//pop</span></span><br><span class="line">myQueue.shift(); <span class="comment">//1</span></span><br><span class="line">myQueue.shift(); <span class="comment">//2</span></span><br><span class="line">myQueue.shift(); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>Priority Queue优先队列</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PriorityQueue = <span class="built_in">require</span>(<span class="string">'./priorityqueue'</span>)</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">p.enq(<span class="number">1</span>);</span><br><span class="line">p.enq(<span class="number">3</span>);</span><br><span class="line">p.enq(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.deq())</span><br><span class="line"><span class="built_in">console</span>.log(p.deq())</span><br><span class="line"><span class="built_in">console</span>.log(p.deq())</span><br><span class="line"><span class="built_in">console</span>.log(p);</span><br></pre></td></tr></table></figure>
<h2 id="二、算法"><a href="#二、算法" class="headerlink" title="二、算法"></a>二、算法</h2><p>算法不像数据结构，每个人都有每个人的想法，思维的不一样，导致写出来的代码精炼程度也不大一样，所以，我这里在我自己与室友的帮助下，会写下自己在 <a href="https://leetcode.com/" target="_blank" rel="noopener">LeetCode</a>中的题解，与之对应的算法。</p>
<h3 id="1-尺取法"><a href="#1-尺取法" class="headerlink" title="1.尺取法"></a>1.尺取法</h3><blockquote>
<p>去一块一块地去截取你所要的序列，一旦不满足就后自增1，前再去探索，使其满足要求，也如同蚯蚓的爬动，用O(n)的复杂度，求得最优值。</p>
</blockquote>
<p><img src="http://images.cnitblog.com/blog/597004/201408/291224259702079.jpg" alt="图解"><br><img src="https://yuhaomin.github.io/uploads/images/1-1%E5%B0%BA%E5%8F%96%E6%B3%95.png" alt="图解"><br>尺取法我想我这种程度是想不到类似巧妙的算法的，我之前的算法自己想想就觉得太复杂了。而且呢。没有AC掉题，代码真是又臭又长。之后寻求了室友的帮助提示，他告诉了我尺取法来解决这类序列不动求其最长或最短的方法，一下子就把问题变得简单了。<br>所以以后遇到类似的问题，不用在意是数字还是字母，只要要求序列不排序，就可以用此方法解决。</p>
<p>举个 <a href="https://leetcode.com/" target="_blank" rel="noopener">LeetCode</a> 中较为形象的题型</p>
<h4 id="1-例题：求最长子字符串"><a href="#1-例题：求最长子字符串" class="headerlink" title="1.例题：求最长子字符串"></a>1.例题：求最长子字符串</h4><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">Longest Substring Without Repeating Characters</a></p>
<blockquote>
<p><strong>Description</strong><br>Given a string, find the length of the longest substring without repeating characters.<br>Examples:<br>Given <code>&quot;abcabcbb&quot;</code>, the answer is <code>&quot;abc&quot;</code>, which the length is 3.<br>Given <code>&quot;bbbbb&quot;</code>, the answer is <code>&quot;b&quot;</code>, with the length of 1.<br>Given <code>&quot;pwwkew&quot;</code>, the answer is <code>&quot;wke&quot;</code>, with the length of 3. Note that the answer must be a substring, <code>&quot;pwke&quot;</code> is a subsequence and not a substring.</p>
</blockquote>
<p>这里它还提醒我们跟之前的题不太一样，这个序列不准变，不是求最长子序列，是最长子字符串<br>来说说我之前的复杂的想法吧，首先将字符串转化成数组，然后慢慢去用 <code>new Map()</code> 这类数据类型去找不一样的字符串，如果不对记录下其长度，放入数组中，最后求出最大值，<br>！但是这个解决方案看似完美，但有致命的缺点，就是忽略了第一次确定了那个最长序列之中的有可能的最长序列。所以让我们还是用最优的方案吧–尺取法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">var</span> Imax = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;s.length &amp;&amp; !m.has(s.charAt(j)))&#123;</span><br><span class="line">      m.set(s.charAt(j));</span><br><span class="line">      j++; </span><br><span class="line">    &#125;</span><br><span class="line">    Imax = <span class="built_in">Math</span>.max(Imax, j-i);</span><br><span class="line">    <span class="keyword">if</span>(j &gt;= s.length)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    m.delete(s.charAt(i++));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Imax;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong><br>这个整体思路就相当清晰了，除了避免了字符串变数组的多余的循环，也添加了尺取法的构思，可看到，while这个语句在算法中是经常能用到的。<br>首先利用es6的新特性，map数据结构，使这个数据有数据有字典的属性，可以方便的查询。然后定义头与尾，用头去探索，尾部去迭代，只要头部探索完毕，就释放尾部进1。使头部继续去探索。最后求得最大值。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>尺取法</tag>
        <tag>堆栈</tag>
        <tag>队列</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>重新整理下自己，轻装上阵</title>
    <url>/2017/07/08/%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%8B%E8%87%AA%E5%B7%B1%EF%BC%8C%E8%BD%BB%E8%A3%85%E4%B8%8A%E9%98%B5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大学三年，从学习图片处理开始，再到视频制作，最后转到真正的去敲代码，这个过程现在看来还是挺令人不可思议的。不过，现在经历过面试，笔试，虽然在社团中还是十分自信的，但在社会中，面对社会上的人还是跟你在学校里遇到的情况是十分不一样的。不得不说，社会很险恶，你不懂交际，不懂一些交情，更直白的说吧。除了直接推荐这样的方式，一切都是公平的。</p>
<a id="more"></a>
<p>所以，你不能靠很多你自己，就比如说我，自己在大学里的想法做的项目来让人家刮目相看，并且你能面试的工作职务少之又少，其它的要求很高，你并没有考得相应的证，或者真正的实习经验，人家根本不会去看你。</p>
<p>所以，总之，好的公司需要的人才分很多种，比如在前端，公司需要的是人才有两种，一种专门设计，这种不管，还有一类就是动画，通过JavaScript设计类似3D的动画，像这类工作，工资一定是比第一类的高得多，但是这类人才，在现在的情境下，必须有一直创新地去学习地想法，其中一个最大的原因就是JavaScript这门语言太酷炫了，使得前端这朵花开的一塌糊涂，现在已经可以去抢占后端的饭碗了。</p>
<p>其它比如java，比如C#，两大除了C/C++以外的通用全能语言渐渐变得不是那么引人注意了，我同样也是这么认为，首先IDE太大，对于入门者完全不懂它加载地这么慢，到底与我有什么关系。所以，以我地认知来看，那种专一性，简洁性的语言，会慢慢蚕食这类通用型语言。</p>
<p>可以很形象的举个例子，现在除了对于性能不高的场景下，解释性语言已经很流行了，比如python，JavaScript，等等其它语言，它们不必编译，但是功能很强大，操作上手很快，特别是在某些领域中，它们简直是那里的老大，用它的人都喜欢它的语法，它们代码风格，更直接点，喜欢它的规范（因为规范就是从人群中来的）</p>
<h1 id="描述问题"><a href="#描述问题" class="headerlink" title="描述问题"></a>描述问题</h1><ul>
<li><a href="#到底怎么整理自己的博客？">到底怎么整理自己的博客？</a></li>
<li><a href="#GitHub中的项目如何正确维护？不泄露一些重要密码？">GitHub中的项目如何正确维护？不泄露一些重要密码？</a></li>
<li><a href="#书签的整理问题，到底如何整理技术书签？">书签的整理问题，到底如何整理技术书签？</a></li>
<li><a href="#优秀博客中的知识点如何整理？">优秀博客中的知识点如何整理？</a></li>
<li><a href="#实战视频中的要点如何记录？">实战视频中的要点如何记录？</a></li>
<li><a href="#自己探索中的经验，想法，或者突然的项目该如何记录？">自己探索中的经验，想法，或者突然的项目该如何记录？</a></li>
<li><a href="#团队思想探索">团队思想探索</a><h2 id="到底怎么整理自己的博客？"><a href="#到底怎么整理自己的博客？" class="headerlink" title="到底怎么整理自己的博客？"></a>到底怎么整理自己的博客？</h2>其实探索过许多写博客的方法，wordpress，自己搭建博客，github静态挂载（hexo）<br>其实与有些大佬一样，不同的人有不同的困惑，在我看来，wordpress是一个原生PHP搭建的著名的博客框架，虽然很好用，但是！问题还是有很多的，比如，头像不能正常显示，因为墙的缘故，当你注册过之后，几天之内，你可能就会发现有不明的账户会在你的博客上注册，还有就是图片容量问题，不过可以用七牛云免费的1G空间帮你解决这个尴尬的问题。结果当然是不太理想。<br>自己搭建博客，虽然费时费力，但可以很好的找出问题所在，不用费力的去看看源代码或者着急的问大佬的问题，但缺点也是有的，性能可能不太好，功能会有一些单一，最主要的还是安全性得不到保证。<br>hexo等一些静态博客，都不错，就是图片整理困难，在文档中插入图片不是那么的方便。最喜欢的特点就是主题真的十分多。<h2 id="GitHub中的项目如何正确维护？不泄露一些重要密码？"><a href="#GitHub中的项目如何正确维护？不泄露一些重要密码？" class="headerlink" title="GitHub中的项目如何正确维护？不泄露一些重要密码？"></a>GitHub中的项目如何正确维护？不泄露一些重要密码？</h2>在我现在的项目中，可能你还是可以发现，在项目特别是<code>PHP</code>的项目中，其配置文件仍存有一些我遗忘删除的<code>php</code>代码，里保存着我的一些数据库的密码资料。这也难免，在<code>windows</code>下完成的项目，移交到服务器端总是不怎么方便，所以当时很童真的我以<code>github</code>为中间渠道，<code>push</code>&amp;<code>pull</code>上传下载，以用来本地与服务器之间的同步。可是现在来看，这种方式肯定有不可取的地方。<h2 id="书签的整理问题，到底如何整理技术书签？"><a href="#书签的整理问题，到底如何整理技术书签？" class="headerlink" title="书签的整理问题，到底如何整理技术书签？"></a>书签的整理问题，到底如何整理技术书签？</h2>书签的整理问题，我认为是一个比较好解决的问题。<br>之前的过程中，我凡是遇到好的网页，好的博客，更甚至说好的文章，我总会点击chrome地址栏右侧的收藏icon，以方便今后阅读，不过现在看来这是一个近似于无效的方案，收藏的当时只是出于兴趣，你未必能够在将来去回顾你这些所谓的好文。<h2 id="优秀博客中的知识点如何整理？"><a href="#优秀博客中的知识点如何整理？" class="headerlink" title="优秀博客中的知识点如何整理？"></a>优秀博客中的知识点如何整理？</h2>一篇冗长的好文章，虽然是一篇好文，但你需要的点只有那几点，而且是希望以后融入到你的程序，或者总结文章上去的。如果你只是翻翻而过，或者对一些敲敲而过，很快你会失去这么有用的代码。所以，即时性的收藏方式一个很好的解决方案，你可以将一并收纳，并在有需要的时候，互相贯通。既可以学习又能复习的方法，岂不最佳？<h2 id="实战视频中的要点如何记录？"><a href="#实战视频中的要点如何记录？" class="headerlink" title="实战视频中的要点如何记录？"></a>实战视频中的要点如何记录？</h2>这个问题与上一个问题类似，唯一不同的就是视频一种说好但不是很方便的一种教学方式。<br>没错，视频是一种十分稀缺的资源，他能让一些入门，或者缺乏独自学习官网或者源码的孩子开启了新的一扇门。不过缺点也是依稀可见的：</li>
</ul>
<p>1.下载它容量大，使得你不能很好的携带。<br>2.复习，回顾的时候，你很难从中寻找，这与文档相比就让很明显了。<br>3.老师的教学方式都十分不一样，所以你需要适合多样化的教学方式。</p>
<h2 id="自己探索中的经验，想法，或者突然的项目该如何记录？"><a href="#自己探索中的经验，想法，或者突然的项目该如何记录？" class="headerlink" title="自己探索中的经验，想法，或者突然的项目该如何记录？"></a>自己探索中的经验，想法，或者突然的项目该如何记录？</h2><p>这种探索，我可以说，你们也能经常碰到，我举一个很简单的例子，比如，在学习微信公众平台的时候，你可能希望能够搭建一个属于自己的平台，并十分希望大家一起来看你的优秀管理，也难免说起来很容易，但做起来是很困难的，你在很好的管理的同时，你需要对你的文章有很好的筛选，如果你有很好的算法，你简直可以在企业中获得很好的职位，因为这些智能的算法，是能够很好的解决工作繁琐，错误过多的问题。<br>想法该如何记录？？Emmm<br>就写在书上吧。</p>
<h2 id="团队思想探索"><a href="#团队思想探索" class="headerlink" title="团队思想探索"></a>团队思想探索</h2><p>团队在组建与管理，是我现在十分想做的一件事，不过并不是每日签到签退这类活，我只想对成员有更好的教育意义，对这个团队的发展有更好的启蒙想法。当然这些想法希望不是全部出自于我，我也热于和我志同道合的人，或者有些激进想法的人能有思想上的冲击，能说服我，更新迭代我的世界观，说真的，我希望能够天天更新我对世界的认知，对知识不断索取，是我热爱的。</p>
<h1 id="实际解决方案"><a href="#实际解决方案" class="headerlink" title="实际解决方案"></a>实际解决方案</h1><ul>
<li><a href="#到底怎么整理自己的博客？我的解答">到底怎么整理自己的博客？我的解答</a></li>
<li><a href="#GitHub中的项目如何正确维护？不泄露一些重要密码？我的解答">GitHub中的项目如何正确维护？不泄露一些重要密码？我的解答</a></li>
<li><a href="#书签的整理问题，到底如何整理技术书签？我的解答">书签的整理问题，到底如何整理技术书签？我的解答</a></li>
<li><a href="#优秀博客中的知识点如何整理？我的解答">优秀博客中的知识点如何整理？我的解答</a></li>
<li><a href="#实战视频中的要点如何记录？我的解答">实战视频中的要点如何记录？我的解答</a></li>
<li><a href="#自己探索中的经验，想法，或者突然的项目该如何记录？我的解答">自己探索中的经验，想法，或者突然的项目该如何记录？我的解答</a></li>
<li><a href="#团队思想探索。我的解答">团队思想探索。我的解答</a><h2 id="到底怎么整理自己的博客？我的解答"><a href="#到底怎么整理自己的博客？我的解答" class="headerlink" title="到底怎么整理自己的博客？我的解答"></a>到底怎么整理自己的博客？我的解答</h2>博客这个是个可以讨论的一个小问题，很多很多小白，包括之前的我，都有一个天真的想法：作为一个程序猿，自己的技术笔记越多，就感觉自己越厉害。不过，现在来看，博客这个可不是小白的垃圾场，我们不希望有一些不易懂，或者写的很糟糕的文章呈现在百度搜索页的前列，google的前边，希望某个问题的解决，能有一些很规范的博文能够给迷失者指引方向。<br>我们要确立一个很明确的一个核心–“博客是用来干什么的？”-&gt;&gt;“分享经验或者人们所需要的点。”</li>
</ul>
<p>1.不要单一的造轮子，做轮子（具有一定的技术性的文摘）。<br>2.自己平日里的日志，日记，想法，或者感受（个人日记是个不错的归档）。<br>3.面试（给自己，也给学弟学妹一点自己小小的经验）。<br>4.靠自己技术，抓取或者分析的大量数据的展示（数据测试分析）。</p>
<h2 id="GitHub中的项目如何正确维护？不泄露一些重要密码？我的解答"><a href="#GitHub中的项目如何正确维护？不泄露一些重要密码？我的解答" class="headerlink" title="GitHub中的项目如何正确维护？不泄露一些重要密码？我的解答"></a>GitHub中的项目如何正确维护？不泄露一些重要密码？我的解答</h2><p>通过百度还是<code>stackoverflow</code>还是挺辛苦的找到一种方法去解决如何将已经add的文件，在接下来的修改中，不会引起git的关注，同样的方便了local（本地），Server（服务器），Github（远程托管）的过程中不会很麻烦的去修改配置文件，同样也避免了懒得去修改配置文件带来的数据库密码泄露的问题。<br>方法是：不想继续跟踪的文件<br><code>git update-index --assume-unchanged &lt;file&gt;</code><br>反之使其正常跟踪<br><code>git update-index --no-assume-unchanged &lt;file&gt;</code><br>如果有其它解决方案，你也可以私聊我。</p>
<ul>
<li><h2 id="书签的整理问题，到底如何整理技术书签？我的解答"><a href="#书签的整理问题，到底如何整理技术书签？我的解答" class="headerlink" title="书签的整理问题，到底如何整理技术书签？我的解答"></a>书签的整理问题，到底如何整理技术书签？我的解答</h2></li>
<li><h2 id="优秀博客中的知识点如何整理？我的解答"><a href="#优秀博客中的知识点如何整理？我的解答" class="headerlink" title="优秀博客中的知识点如何整理？我的解答"></a>优秀博客中的知识点如何整理？我的解答</h2></li>
<li><h2 id="实战视频中的要点如何记录？我的解答"><a href="#实战视频中的要点如何记录？我的解答" class="headerlink" title="实战视频中的要点如何记录？我的解答"></a>实战视频中的要点如何记录？我的解答</h2></li>
<li><h2 id="自己探索中的经验，想法，或者突然的项目该如何记录？我的解答"><a href="#自己探索中的经验，想法，或者突然的项目该如何记录？我的解答" class="headerlink" title="自己探索中的经验，想法，或者突然的项目该如何记录？我的解答"></a>自己探索中的经验，想法，或者突然的项目该如何记录？我的解答</h2>我觉得这三点可以一起说明<br>假装有一个图可以描述我的情景<br>所以不仅在浏览器中要有Search书签文件夹，Temp书签文件夹，Future文件夹，在需要在OneNote中新建书签与Future书签，Future书签将逐渐归纳到书签中，也就是OneNote了。<br>换句话来说，你在OneNote只要创建一个用来管理临时的书签就可以了。<h2 id="团队思想探索。我的解答"><a href="#团队思想探索。我的解答" class="headerlink" title="团队思想探索。我的解答"></a>团队思想探索。我的解答</h2>引用百年老店IBM总裁彭明盛的一句话–“唯一需要保持的新年，就是要不断做出改变”。<br>当今互联网时代，商业环境复杂多变…接下来的话可能跟我们程序员一点关系都没有，可是遭遇的问题是一样，一致的，就是语言这类技术，发展的越来越快，随着越来越多的人的加入，新语言一定是不断产生并与就语言产生火花的。一个IT从业人员需要在信息上不断获取，在头脑上不断更新，有着创新的理念，万事学会去接纳，才能被称为不落伍的人。<br>此段未完待续~</li>
</ul>
<h1 id="参考论文与知乎"><a href="#参考论文与知乎" class="headerlink" title="参考论文与知乎"></a>参考论文与知乎</h1><p>1.<a href="http://www.docin.com/p-682445311.html" target="_blank" rel="noopener">IT部门只能演变机器重新定义</a><br>2.<a href="https://www.zhihu.com/question/46790643" target="_blank" rel="noopener">IT项目管理者的个人发展方向如何定位？</a></p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>ME</tag>
      </tags>
  </entry>
  <entry>
    <title>学习jQuery源代码之二>>构建对象与加载</title>
    <url>/2017/07/01/%E5%AD%A6%E4%B9%A0jQuery%E6%BA%90%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%BA%8C-%E6%9E%84%E5%BB%BA%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<blockquote><p>此系列文章只是为我（当然如果你能看懂的话也是为你们）稍微深入JavaScript的难点，毕竟作为前端工程师并不是那么简单的。这篇<a href="/2017/06/21/学习jQuery源代码之一-模块与对象的构造/#more">文章的前一章</a></p>
</blockquote>

<h1 id="jQuery的构建对象"><a href="#jQuery的构建对象" class="headerlink" title="jQuery的构建对象"></a>jQuery的构建对象</h1><p>jQuery 神奇之处有很多，其中一个就是<code>jQuery</code>对<code>DOM</code>对象的包装。<br>我们都知道<code>jQuery</code>的入口开头就是一个<code>$</code>符.<br>函数原型<code>$([arguments...])</code><br> <a id="more"></a><br>通过传递参数的不同，实现了9种方法的重载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. jQuery([selector,[context]])</span><br><span class="line">2. jQuery(element)</span><br><span class="line">3. jQuery(elementArray)</span><br><span class="line">4. jQuery(object)</span><br><span class="line">5. jQuery(jQuery object)</span><br><span class="line">6. jQuery(html,[ownerDocument])</span><br><span class="line">7. jQuery(html,[attributes])</span><br><span class="line">8. jQuery()</span><br><span class="line">9. jQuery(callback)</span><br></pre></td></tr></table></figure>
<p>分别有选择器，<code>DOM</code>处理，<code>DOM</code>加载的操作<br>为什么<code>jQuery</code>也有数组一样的操作呢？<br>起因是<code>JavaScript</code>独有的原型的概念，然后<code>jQuery</code>自带类数组的存储结构，一旦这两者通过<code>prototype</code>链接起来，那我们就可以将<code>DOM</code>对象，既可以用对象一样操作，也可以像数组一样操作。<br>接下来我们通过一个简单的示例来模拟下<code>jQuery</code>的对象大致构建</p>
<iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/u7s227j2/embedded/js,html/light" frameborder="0" allowfullscreen></iframe>

<p>在代码中有一句可能很疑惑，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!(this instanceof aquery))&#123;</span><br><span class="line">  return new aquery(selector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>instanceof</code>用于当前环境是否在局部环境中，使<code>this</code>也就是上下文处于这个对象之中，而不是去引用<code>window</code>这个全局变量<br><code>return new aquery(selector);</code><br>这个不仅是去创建一个对象变量，更是去创建一个对象环境<br>这样才有了以下调用<code>this</code>不会出错的现象<br>这里不要搞错之前用<code>JavaScript</code>去创建一个类，也就是<code>contructor object</code>构造对象<br>之前用的不是匿名函数，而这里是将一个匿名函数赋值给一个变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.sayHello = function()&#123;alert(&quot;hello, I am &quot;+this.name);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我这里也拿出另一种创建对象的方法，虽然这是一个简陋的写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person1 = new Object();</span><br><span class="line">person1.name = &quot;mike&quot;;</span><br><span class="line">person1.sayHello = function()&#123;alert(&quot;hello&quot;);&#125;;</span><br></pre></td></tr></table></figure>
<p>注意这里就不能用this了，当然也有其它方法，我这里就不再演示，主要是为了比较上面的<code>new aquery()</code>这个对象有什么区别。<br><code>jQuery</code>的加载<br>首先还是要讲讲面试要考的地方</p>
<blockquote><p>比如DOM文档加载的步骤：<br>(1) 解析HTML结构。<br>(2) 加载外部脚本和样式表文件。<br>(3) 解析并执行脚本代码。<br>(4) 构造HTML DOM模型。//ready<br>(5) 加载图片等外部文件。<br>(6) 页面加载完毕。//load</p>
</blockquote>
<p>可以很明显看出ready的方法在DOM模型结构处理完就可以运行，然后就是开始加载图片资源，直到页面全部加载完毕才可以执行load里面的代码。<br>所以我们该如何分配代码的运行呢？虽然这个问题我也没有仔细考虑过，不过大致情况还是有分很多种的：<br>比如要用js构造DOM结构的一定要放在ready时，不过为了页面加载速度快，如果你的代码运行时间长，要么精简代码的时长，也就是使用更优秀的算法，要么删减要加载 DOM 的数量<br>我们来看看jQuery是如何处理文档加载时机问题的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery.ready.promise = function( obj ) &#123;</span><br><span class="line">    if ( !readyList ) &#123;</span><br><span class="line">        readyList = jQuery.Deferred();</span><br><span class="line">        if ( document.readyState === &quot;complete&quot; ) &#123;</span><br><span class="line">            // Handle it asynchronously to allow scripts the opportunity to delay ready</span><br><span class="line">            setTimeout( jQuery.ready );</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            document.addEventListener( &quot;DOMContentLoaded&quot;, completed, false );</span><br><span class="line">            window.addEventListener( &quot;load&quot;, completed, false );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return readyList.promise( obj );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Query</code>的<code>ready</code>是通过<code>promise</code>给包装过的，这也是<code>jQuery</code>擅长的手法，统一了回调体系，以后我们会重点谈到。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener">addEventListener</a>这个方法虽然在用在了<code>document</code>上，但是它继承了<code>node</code>这个父元素，<code>node</code>这个父元素又继承了<code>EventTarget</code>这个最大的元素<br>可见<code>jQuery</code>兼容的具体策略：针对高级的浏览器，我们当前很乐意用<code>DOMContentLoaded</code><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events" target="_blank" rel="noopener">EventLister</a>事件了，省时省力。<br>如果是旧的浏览器，它是通过判断<code>IE</code>的<code>doScroll</code>是否加载完毕在判断的<br>这都是我们在第一时间内处理<code>ready</code>加载的问题，如果<code>ready</code>在页面加载完毕后呢？</p>
<p><code>jQuery</code>就必须针对这样的情况跳过绑定了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ( document.readyState === &quot;complete&quot; ) &#123;</span><br><span class="line">     // Handle it asynchronously to allow scripts the opportunity to delay ready</span><br><span class="line">     setTimeout( jQuery.ready );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>直接通过查看<code>readyState</code>的状态来确定页面的加载是否完成了。这里会给一个定时器的最小时间后去执行，主要保证执行的正确。</p>
<iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/cex77mcw/embedded/js/light" frameborder="0" allowfullscreen></iframe>

<h1 id="jQuery多库共存处理"><a href="#jQuery多库共存处理" class="headerlink" title="jQuery多库共存处理"></a>jQuery多库共存处理</h1><p>多库共存是为了避免全局变量$一直被jQuery一直占用，jQuery的内置noConflict()的函数可以将$变量转让出去，避免其它库用不了$的问题发生</p>
<iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/03cxmkn3/embedded/js/light" frameborder="0" allowfullscreen></iframe>
<p>当然其中的原因也很简单，就是利用变量环境交换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var _jQuery = window.jQuery,</span><br><span class="line">    _$ = window.$;</span><br><span class="line"></span><br><span class="line">jQuery.noConflict = function( deep ) &#123;</span><br><span class="line">    if ( window.$ === jQuery ) &#123;</span><br><span class="line">        window.$ = _$;</span><br><span class="line">    &#125;</span><br><span class="line">if ( deep &amp;&amp; window.jQuery === jQuery ) &#123;</span><br><span class="line">        window.jQuery = _jQuery;</span><br><span class="line">    &#125;</span><br><span class="line">    return jQuery;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过类似swap交换的概念，先把之前的存在的命名空间给缓存起来，通过对比当前的命名空间达到交换的目的，首先，我们先判断下当前的的$空间是不是被<code>jQuery</code>接管了，如果是则让出控制权给之前的_$引用的库，如果传入<code>deep</code>为<code>true</code>的话等于是把<code>jQuery</code>的控制权也让出去了</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>前端</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>学习jQuery源代码之一>>模块与对象的构造</title>
    <url>/2017/06/21/%E5%AD%A6%E4%B9%A0jQuery%E6%BA%90%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%80-%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0/</url>
    <content><![CDATA[<blockquote><p>此系列文章只是为我（当然如果你能看懂的话也是为你们）稍微深入JavaScript的难点，毕竟作为前端工程师并不是那么简单的。</p>
</blockquote>

<p>一边看老师的视频，一边敲代码，只知道效果，却不能完全理解其它的意思，偶尔会有看不懂的地方，还得自己百度一会儿，不过一会儿就忘了。这是一种急于求成的方法，做多了也无大用处，项目做多了，也应该回头望望，从零开始，能去读懂别人的代码（当然是比如著名框架的代码），学着别人的方式去写一些比较有意义的小插件还是不错的。</p>
<p>多做少说，我就赶紧开始吧。</p>
<p>这里我阅读的是<code>jQuery2.1</code>的源码，应该不会有多大差别。<br> <a id="more"></a></p>
<h1 id="首先，记住下会考的面试题："><a href="#首先，记住下会考的面试题：" class="headerlink" title="首先，记住下会考的面试题："></a>首先，记住下会考的面试题：</h1><blockquote><p>jQuery是继prototype之后又一个优秀的Javascript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。</p>
<p>The Write Less,Do More（写更少，做更多），无疑就是jQuery的核心理念，简洁的API、优雅的链式、强大的查询与便捷的操作。从而把jQuery打造成前端世界的一把利剑，所向披靡！</p>
<footer><strong>慕课网</strong></footer></blockquote>

<ul>
<li>重点1：简洁的API（不仅简洁而且时常能用到）、优雅的链式、通过正则写的强大的选择器…</li>
<li>重点2：2.1之后也就现在我用的版本就不支持旧的浏览器了，我这里就不得不吐槽一句，兼容这事我不想搞啊！！！（让别人去搞好了，我学好新技术，（偷笑~））</li>
<li>重点3：这也是特色，就是好多插件都必须在jQuery的前提下才能使用，这谁开发过网站的都知道，用个图表，用个轮播图，等等，不先引用个jQuery你就别想有优美的效果！</li>
</ul>
<iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/kdj8t92j/embedded/js/light" frameborder="0" allowfullscreen></iframe>

<h1 id="jQuery的整体架构"><a href="#jQuery的整体架构" class="headerlink" title="jQuery的整体架构"></a>jQuery的整体架构</h1><p>虽然不太懂，但也根据慕课网是的提一提</p>
<img src="http://img.mukewang.com/53fa8fec0001754806930473.jpg" class="" title="就看看">

<blockquote><p>五大块：<br>jQuery按我的理解分为五大块，选择器、DOM操作、事件、AJAX与动画，那么为什么有13个模块？因为jQuery的设计中最喜欢的做的一件事，就是抽出共同的特性使之“模块化”，当然也是更贴近S.O.L.I.D五大原则的“单一职责SRP”了，遵守单一职责的好处是可以让我们很容易地来维护这个对象，比如，当一个对象封装了很多职责的时候，一旦一个职责需要修改，势必会影响该对象的其它职责代码。通过解耦可以让每个职责更加有弹性地变化。<br>我们来看看jQuery文档针对业务层的Ajax的处理提供了一系列的门面接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.ajaxComplete()</span><br><span class="line">.ajaxError()</span><br><span class="line">.ajaxSend()</span><br><span class="line">.ajaxStart()</span><br><span class="line">.ajaxStop()</span><br><span class="line">.ajaxSuccess()</span><br></pre></td></tr></table></figure>
底层接口：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery.ajax()</span><br><span class="line">jQuery.ajaxSetup()</span><br></pre></td></tr></table></figure>
快捷方法：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery.get()</span><br><span class="line">jQuery.getJSON()</span><br><span class="line">jQuery.getScript()</span><br><span class="line">jQuery.post()</span><br></pre></td></tr></table></figure>
jQuery接口的设计原理
业务逻辑是复杂多变的，jQuery的高层API数量非常多，而且也非常的细致，这样做可以更友好的便于开发者的操作，不需要必须在一个接口上重载太多的动作。我们在深入内部看看Ajax的高层方法其实都是统一调用了一个静态的jQuery.ajax方法，代码见右侧代码编辑器（27-43行）。
在jQuery.ajax的内部实现是非常复杂的，首先ajax要考虑异步的处理与回调的统一性，所以就引入了异步队列模块（Deferred）与回调模块（Callbacks）, 所以要把这些模块方法在ajax方法内部再次封装成、构建出一个新的jQXHR对象，针对参数的默认处理，数据传输的格式化等等。<footer><strong>慕课网慕课老师说：</strong></footer></blockquote>

<h1 id="jQuery是如何处理命名空间"><a href="#jQuery是如何处理命名空间" class="headerlink" title="jQuery是如何处理命名空间"></a>jQuery是如何处理命名空间</h1><p>让我们开始学习下jQuery是如何处理命名空间中变量名污染的问题的。<br>没在学习之前，我们想想如何创建一个给自己使用的方法或者变量？</p>
<h2 id="1、原始写法"><a href="#1、原始写法" class="headerlink" title="1、原始写法"></a>1、原始写法</h2><p>可能就只是简单的放在了一块了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　function m1()&#123;</span><br><span class="line">　　　　//...</span><br><span class="line">　　&#125;</span><br><span class="line">　　function m2()&#123;</span><br><span class="line">　　　　//...</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，这就是在全局在window污染了这个window变量，你可以同时在任意位置调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m1()</span><br><span class="line">//或者</span><br><span class="line">window.m1()</span><br></pre></td></tr></table></figure>
<h2 id="2、对象的方式"><a href="#2、对象的方式" class="headerlink" title="2、对象的方式"></a>2、对象的方式</h2><p>把一个模块写成一个对象，把模块的成员都放在这个对象里就不会污染全局了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var module1 = new Object(&#123;</span><br><span class="line">  _count: 0,</span><br><span class="line">  m1: function()&#123;</span><br><span class="line">    //…dosomething</span><br><span class="line">  &#125;,</span><br><span class="line">  m2:function()&#123;</span><br><span class="line">    //..do otherthing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用的时候你就可以调用对象里的属性就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module1.m1()</span><br></pre></td></tr></table></figure>
<p>但是这样会暴露对象中私有变量，这在C#，C++都是有private可以用来保护的，换另一种吧。</p>
<h2 id="3、立即执行函数写法"><a href="#3、立即执行函数写法" class="headerlink" title="3、立即执行函数写法"></a>3、立即执行函数写法</h2><p>让我首先学习一下什么叫立即执行函数（Immediately-Invoked Function Expression，IIFE）<br>其实我现在也只是懂一点而已，大致说下<br>首先我们先要理解下<code>Javascript</code>中比较特别的一点（这类特点十分多），叫做高阶函数（Higher-order function）<br>理解这一点之前呢，我还需要说明一点的就是JavaScript中的什么变量都是一个对象，不过其中比较特殊的一点就是函数对象，他们除了可以将变量成为一个函数，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sum = function(x, y)&#123;return x + y;&#125;</span><br></pre></td></tr></table></figure>
<p>也可以在JavaScript中当一个类来使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.greeting = function() &#123;</span><br><span class="line">    alert(&apos;Hi! I\&apos;m &apos; + this.name + &apos;.&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&apos;Bob&apos;);</span><br><span class="line">var person2 = new Person(&apos;Sarah&apos;);</span><br></pre></td></tr></table></figure>
<p>讲完函数也是一个特殊的变量之后，我们就将一起混合使用一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var f = function(x,y,fun)&#123;return fun(x,y);&#125;</span><br><span class="line">f(1,2,sum)//3</span><br></pre></td></tr></table></figure>
<p>或者我们再讲一个比较抽象的函数吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pow = function(n)&#123;</span><br><span class="line">  return function(x)&#123;</span><br><span class="line">    return Math.pow(x,n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var pow2 = pow(2);</span><br><span class="line">// var pown = pow(n) Pseudocode</span><br><span class="line">pow2(2);//4</span><br></pre></td></tr></table></figure>
<p>像这样类似的不返回的是值，而是一个定义了的函数，再举一个没有参数的例子可能会更加形象点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function lazy_sum(arr)&#123;</span><br><span class="line">  return function sum ()&#123;</span><br><span class="line">    return arr.reduce(function(x, y)&#123;</span><br><span class="line">      return x+y;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以写成这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function lazy_sum(arr) &#123;</span><br><span class="line">    var sum = function () &#123;</span><br><span class="line">        return arr.reduce(function (x, y) &#123;</span><br><span class="line">            return x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var f = lazy_sum([1, 2, 3, 4, 5]); // function sum()</span><br></pre></td></tr></table></figure>
<p>调用函数f时，才真正计算求和的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(); // 15</span><br></pre></td></tr></table></figure>
<p>在一个<code>lazy_sum</code>函数中又定义了<code>sum</code>函数，内部函数<code>sum</code>引用了<code>lazy_sum</code>的参数，重点是这个引用是自上而下的，在使用时，赋值<code>f</code>的值先要定义<code>arr</code>也就是<code>lazy_sum</code>中的参数，再调用<code>f()</code>时，并没有参数的传递。<br>当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。<br>但是这类闭包虽然用起来很方便，但当它碰到循环或者更直接些，遇到返回的函数中有变量能将其中的函数改变的时候，这就出现了问题了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function count() &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    for (var i=1; i&lt;=3; i++) &#123;</span><br><span class="line">        arr.push(function () &#123;</span><br><span class="line">            return i * i;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var results = count();</span><br><span class="line">var f1 = results[0];</span><br><span class="line">var f2 = results[1];</span><br><span class="line">var f3 = results[2]</span><br><span class="line">// 注意 arr返回的是一个匿名函数数组[function()&#123;&#125;,function()&#123;&#125;,function()&#123;&#125;]</span><br></pre></td></tr></table></figure>
<p>注意由于是闭包（Closure）的特性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f1()//16</span><br><span class="line">f2()//16</span><br><span class="line">f3()//16</span><br></pre></td></tr></table></figure>
<p>由于返回的函数中引用了i这个变量，在<code>var results = count();</code>时，<code>Closure</code>中的<code>i</code>值早已变为<code>4</code>，所以结果都为<code>16</code>，问我怎么看到<code>i</code>值的，我用<code>chrome</code>查看到的。<br>返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。<br>如果你一定要用循环并且一定要使用的时i这个变量怎么办？那就要用标题所说的立即函数写法，也就是去创建一个匿名函数并立即执行的语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function (x) &#123;</span><br><span class="line">    return x * x;</span><br><span class="line">&#125;)(3); // 9</span><br></pre></td></tr></table></figure>
<p>这里闭包谈的很多了，也参考了许多大佬们的资料了，其实真正要谈的时闭包在面向对象中充当一个priavte的一个修饰词，其实也是在模块中防止类似方式二中所暴露的问题，私有变量可以不会修改，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var module4 = (function()&#123;</span><br><span class="line">  var _count = 0;</span><br><span class="line">  return &#123;</span><br><span class="line">    m1: function()&#123;</span><br><span class="line">      _count++;</span><br><span class="line">      return _count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>很明显利用立即函数的写法<code>()()</code>，可以直接在全局中模块中的暴露函数，比如<code>module4.m1()</code><br>但是不用立即函数的写法，闭包的延迟特性也就体现出来了，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var module3 = function()&#123;</span><br><span class="line">  var _count = 0;</span><br><span class="line">  return &#123;</span><br><span class="line">    m1: function()&#123;</span><br><span class="line">      _count++;</span><br><span class="line">      return _count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在全局中<code>module3</code>只是一个返回函数，可以理解为一个待<code>new</code>的一个类，必须</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var c = module3();</span><br></pre></td></tr></table></figure>
<p>然后在调用<code>c.m1()</code>才能正确使用<br>4、去放大一个模块（放大模式）<br>如果一个模块越来越大，有必要将模块分块，或者说去继承另一个必要的模块，这时就必须用这样的一个写法<br>当然这样的写法只适用与立即函数写法，如果不懂什么原理去引用了<code>module3</code>的这个返回来的函数会报<code>module5.m1 is not a function</code>因为毕竟<code>module3</code>中的<code>m1</code>还只是个抽象的东西，不是实际存在的模块或者说可用对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var module5 = (function (mod)&#123;//当然你也可以自我更新,这里些module4</span><br><span class="line">  var _sub = 10;</span><br><span class="line">  mod.m2 = function()&#123;</span><br><span class="line">    _sub--;</span><br><span class="line">    return _sub;</span><br><span class="line">  &#125;</span><br><span class="line">  return mod;</span><br><span class="line">&#125;)(module4);//一定时module4不时module3哦</span><br></pre></td></tr></table></figure>
<p>5、宽放大模式（Loose augmentation）<br>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var module6 = ( function (mod)&#123;</span><br><span class="line">  var _muli = 1;</span><br><span class="line">  mod.m3 = function()&#123;</span><br><span class="line">    _muli *= 2;</span><br><span class="line">    return _muli;</span><br><span class="line">  &#125;</span><br><span class="line">  return mod;</span><br><span class="line">&#125;)(window.module5 || &#123;&#125;);//为什么用window，我认为是为了确保拿到的是全局变量下的mod，以免取到当前变量中的重复变量引发不可预料的错误。</span><br></pre></td></tr></table></figure>
<p>与”放大模式”相比，＂宽放大模式＂就是”立即执行函数”的参数可以是空对象。<br>6、输入全局变量<br>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。<br>为了在模块内部调用全局变量，必须显式地将其他变量输入模块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var module1 = (function ($, YAHOO) &#123;</span><br><span class="line">　//...</span><br><span class="line">&#125;)(jQuery, YAHOO);</span><br></pre></td></tr></table></figure>
<p>上面的module1模块需要使用<code>jQuery</code>库和<code>YUI</code>库，就把这两个库（其实是两个模块）当作参数输入<code>module1</code>。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。这方面更多的讨论，<a href="http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth" target="_blank" rel="noopener">参见Ben Cherry的著名文章《JavaScript Module Pattern: In-Depth》</a>。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>前端</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>Git中的平行时空-分支Branch</title>
    <url>/2017/06/20/Git-branch/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p>本文大多数引用廖老师的教程<br>–@git教程<br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></p>
</blockquote>

<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p>分支这个概念是很神奇的，你不仅可以用来开发，对我来说还可以用特别的软件观察出你的这个项目到底有多么宏伟（虽然现在只是空谈。。）<br> <a id="more"></a><br>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</p>
<p>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</p>
<img src="http://www.liaoxuefeng.com/files/attachments/001384908633976bb65b57548e64bf9be7253aebebd49af000/0" class="" title="漫画">

<p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
<p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。</p>
<p>但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p>
<h1 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h1><p>在重拾篇中，我们已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p>
<p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：</p>
<img src="http://www.liaoxuefeng.com/files/attachments/0013849087937492135fbf4bbd24dfcbc18349a8a59d36d000/0" class="" title="HEAD与master的关系">

<p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长，当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：</p>
<img src="http://www.liaoxuefeng.com/files/attachments/001384908811773187a597e2d844eefb11f5cf5d56135ca000/0" class="" title="dev新分支">

<p>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：</p>
<img src="http://www.liaoxuefeng.com/files/attachments/0013849088235627813efe7649b4f008900e5365bb72323000/0" class="" title="HEAD指向dev">

<p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：</p>
<img src="http://www.liaoxuefeng.com/files/attachments/00138490883510324231a837e5d4aee844d3e4692ba50f5000/0" class="" title="master追到dev">

<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：</p>
<img src="http://www.liaoxuefeng.com/files/attachments/001384908867187c83ca970bf0f46efa19badad99c40235000/0" class="" title="删除了dev分支">

<h1 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h1><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p>
<p>准备新的feature1分支，继续我们的新分支开发：</p>
<blockquote><p>$ git checkout -b feature1<br>Switched to a new branch ‘feature1’</p>
</blockquote>
<p>修改readme.txt最后一行，改为：</p>
<blockquote><p>Creating a new branch is quick AND simple.</p>
</blockquote>
<p>在feature1分支上提交：</p>
<blockquote><p>$ git add readme.txt<br>$ git commit -m “AND simple”<br>[feature1 75a857c] AND simple<br> 1 file changed, 1 insertion(+), 1 deletion(-)</p>
</blockquote>
<p> 切换到master分支：<br> <blockquote><p> $ git checkout master<br>Switched to branch ‘master’<br>Your branch is ahead of ‘origin/master’ by 1 commit.</p>
</blockquote><br>Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。</p>
<p>在master分支上把readme.txt文件的最后一行改为：</p>
<blockquote><p>Creating a new branch is quick &amp; simple.</p>
</blockquote>
<p>提交：</p>
<blockquote><p>$ git add readme.txt<br>$ git commit -m “&amp; simple”<br>[master 400b400] &amp; simple<br> 1 file changed, 1 insertion(+), 1 deletion(-)</p>
</blockquote>
<p> 现在，master分支和feature1分支各自都分别有新的提交，变成了这样：<br> <img src="http://www.liaoxuefeng.com/files/attachments/001384909115478645b93e2b5ae4dc78da049a0d1704a41000/0" class="" title="feature1与master"><br> 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：<br> <blockquote><p> $ git merge feature1<br>Auto-merging readme.txt<br>CONFLICT (content): Merge conflict in readme.txt<br>Automatic merge failed; fix conflicts and then commit the result.</p>
</blockquote><br>果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Your branch is ahead of &apos;origin/master&apos; by 2 commits.</span><br><span class="line">#</span><br><span class="line"># Unmerged paths:</span><br><span class="line">#   (use &quot;git add/rm &lt;file&gt;...&quot; as appropriate to mark resolution)</span><br><span class="line">#</span><br><span class="line">#       both modified:      readme.txt</span><br><span class="line">#</span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<p>我们可以直接查看readme.txt的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure>
<p>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存：</p>
<blockquote><p>Creating a new branch is quick and simple.</p>
</blockquote>
<p>再提交：</p>
<blockquote><p>$ git add readme.txt<br>$ git commit -m “conflict fixed”<br>[master 59bc1cb] conflict fixed</p>
</blockquote>
<p>现在，master分支和feature1分支变成了下图所示：</p>
<img src="http://www.liaoxuefeng.com/files/attachments/00138490913052149c4b2cd9702422aa387ac024943921b000/0" class="" title="处理完问题后">
<p>用带参数的git log也可以看到分支的合并情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*   2671404 conflict fixed</span><br><span class="line">|\</span><br><span class="line">| * 791d353 AND simple</span><br><span class="line">* | 68c7116 &amp; simple</span><br><span class="line">|/</span><br><span class="line">* 2605498 branch test</span><br><span class="line">* 8dc924a add test.txt</span><br><span class="line">* 17f0247 add of files</span><br><span class="line">* 381cacb git tracks changes</span><br><span class="line">* 7e2984e learn git stage is important</span><br><span class="line">* 4db1f01 append GPL</span><br><span class="line">* 7c17cad add distributed</span><br><span class="line">* bb08438 wrote a readme file</span><br></pre></td></tr></table></figure>
<p>最后，删除feature1分支：</p>
<blockquote><p>$ git branch -d feature1<br>Deleted branch feature1 (was 75a857c).</p>
</blockquote>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git远程仓库</title>
    <url>/2017/06/18/Git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p>本文大多数引用廖老师的教程<br>–@git教程<br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></p>
</blockquote>

<h1 id="SSH命令去创建RSA密钥"><a href="#SSH命令去创建RSA密钥" class="headerlink" title="SSH命令去创建RSA密钥"></a>SSH命令去创建RSA密钥</h1><p>实现完自己本地的git添加与提交，并大致了解stage与工作区的概念之后，我们应该去实现一些更加有实用作用的任务了。<br> <a id="more"></a></p>
<p>没错，就是去学习git的分布式distrubed的功能，以防止硬盘奔溃的情况，还有一起协作完成一个项目的作用。</p>
<p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p>
<p>你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？</p>
<p>其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。</p>
<p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>
<p>完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p>
<p>在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p>
<h2 id="第1步：创建SSH"><a href="#第1步：创建SSH" class="headerlink" title="第1步：创建SSH"></a>第1步：创建SSH</h2><p> 在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p>
<blockquote><p>$ ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com" target="_blank" rel="noopener">youremail@example.com</a>“</p>
</blockquote>
<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p>
<p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p>
<h2 id="第2步：登陆GitHub，打开“Account-settings”，“SSH-Keys”页面："><a href="#第2步：登陆GitHub，打开“Account-settings”，“SSH-Keys”页面：" class="headerlink" title="第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面："></a>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</h2><p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：</p>
<img src="http://www.liaoxuefeng.com/files/attachments/001384908342205cc1234dfe1b541ff88b90b44b30360da000/0" class="" title="github上的页面">
<p>点“Add Key”，你就应该看到已经添加的Key：</p>
<img src="http://www.liaoxuefeng.com/files/attachments/0013849083502905a4caa2dc6984acd8e39aa5ae5ad6c83000/0" class="" title="github上的页面">
<p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p>
<p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>
<p>最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</p>
<p>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。</p>
<p>确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>“有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机</p>
<h1 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h1><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>
<h2 id="注册登陆github的账户"><a href="#注册登陆github的账户" class="headerlink" title="注册登陆github的账户"></a>注册登陆github的账户</h2><p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：</p>
<img src="http://www.liaoxuefeng.com/files/attachments/0013849084639042e9b7d8d927140dba47c13e76fe5f0d6000/0" class="" title="创建仓库流程">

<p>在Repository name填入<code>learngit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p>
<img src="http://www.liaoxuefeng.com/files/attachments/0013849084720379a3eae576b9f417da2add578c8612a2e000/0" class="" title="github创建好后的说明">

<p>目前，在GitHub上的这个<code>learngit</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>
<p>现在，我们根据GitHub的提示，在本地的<code>learngit</code>仓库下运行命令：</p>
<blockquote><p>$ git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:<yourusername>/learngit.git</p>
</blockquote>

<p>请千万注意，把上面的<code>&lt;yourusername&gt;</code>替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p>
<p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p>
<p>下一步，就可以把本地库的所有内容推送到远程库上：</p>
<blockquote><p>$ git push -u origin master</p>
</blockquote>
<p>不过如果你是第一次的话会遇到这类问题</p>
<blockquote><p>The authenticity of host ‘github.com (192.30.255.112)’ can’t be established.<br>RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.<br>Are you sure you want to continue connecting (yes/no)? </p>
</blockquote>
<p>你可以选择yes，让git知道并信任github.com</p>
<blockquote><p>ssh <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></p>
</blockquote>
<p>也就是老师说的ssh警告</p>
<h2 id="SSH警告"><a href="#SSH警告" class="headerlink" title="SSH警告"></a>SSH警告</h2><p>当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：</p>
<blockquote><p>The authenticity of host ‘github.com (xx.xx.xx.xx)’ can’t be established.<br>RSA key fingerprint is xx.xx.xx.xx.xx.<br>Are you sure you want to continue connecting (yes/no)?</p>
</blockquote>
<p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。</p>
<p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p>
<p>Warning: Permanently added ‘github.com’ (RSA) to the list of known hosts.<br>这个警告只会出现一次，后面的操作就不会有任何警告了。</p>
<p>如果你实在担心有人冒充GitHub服务器，输入yes前可以对照<a href="https://help.github.com/articles/github-s-ssh-key-fingerprints/" target="_blank" rel="noopener">GitHub的RSA Key的指纹信息</a>是否与SSH连接给出的一致。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>要关联一个远程库，使用命令<code>git remote add origin ``git@server-name:path/repo-name.git</code>；</p>
<p>关联后，使用命令<code>git push -u origin master</code>第一次推送<code>master</code>分支的所有内容；</p>
<p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p>
<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 重拾篇</title>
    <url>/2017/06/17/git%E9%87%8D%E6%8B%BE%E7%AF%87/</url>
    <content><![CDATA[<h1 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h1><blockquote class="blockquote-center"><p>本文大多数引用廖老师的教程<br>–@git教程<br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></p>
</blockquote>

<p>当你需要回到之前某个版本的时候，git的真正用处就达到了</p>
<h2 id="GIT-LOG-官方说明"><a href="#GIT-LOG-官方说明" class="headerlink" title="GIT LOG 官方说明"></a>GIT LOG 官方说明</h2><blockquote><h3 id="NAME"><a href="#NAME" class="headerlink" title="NAME"></a>NAME</h3><p>git-log - Show commit logs</p>
<h3 id="SYNOPSIS"><a href="#SYNOPSIS" class="headerlink" title="SYNOPSIS"></a>SYNOPSIS</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log [&lt;options&gt;] [&lt;revision range&gt;] [[\--] &lt;path&gt;…​]</span><br></pre></td></tr></table></figure>
### DESCRIPTION
Shows the commit logs.
The command takes options applicable to the git rev-list command to control what is shown and how, and options applicable to the git diff-* commands to control how the changes each commit introduces are shown.<footer><strong>@git官方文档</strong><cite><a href="https://git-scm.com/docs/git-log" target="_blank" rel="noopener">git-scm.com/docs/git-log</a></cite></footer></blockquote>
 <a id="more"></a>
<p>根据官方文档来说就是展示你之前提交的<code>commit</code>的<code>log</code>信息<br>如果单单使用<code>git log</code>这条命令<br>它会展示的信息有<br><code>commit id</code><br><code>Author name&lt;email&gt;</code><br><code>Date time</code><br>加上 一条<code>commit</code>当时的注释说明<br>如果想看得更加清楚一些 可以单行显示一个版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br></pre></td></tr></table></figure>
<p>你大可以把它想象成一条时间线，这三个事件按照某种方式连接着，有这样抽象的概念之后，你就可以知道如何回去之前某个版本是如何实现了</p>
<img src="http://www.liaoxuefeng.com/files/attachments/001384907545599be4a60a0b5044447b47c8d8b805a25d2000/0" class="" title="时间线">

<p>git中，<code>HEAD</code>记录现在的<code>commit id</code>也就是为什么你现在的项目打开是你现在所想要的内容，不过我们现在需要回到上一个版本，也就是让HEAD存储上一个版本的<code>commit id</code><br>怎么做呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD &lt;commit id&gt;</span><br></pre></td></tr></table></figure>
<p>或如只是单单回到上一个版本有其他简单的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure>
<p>上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。<br>但是，如果我们后悔回退了怎么办？比如之前有比较重要的信息<br>办法其实就还是那些，只要你记住了那些版本号就可以回去，所以一般你的命令行不要关闭，版本号的信息还存留在你的缓存区<br>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p>
<img src="http://www.liaoxuefeng.com/files/attachments/001384907584977fc9d4b96c99f4b5f8e448fbd8589d0b2000/0" class="" title="HEAD1">
<p>改为指向<code>add distributed</code>：</p>
<img src="http://www.liaoxuefeng.com/files/attachments/001384907594057a873c79f14184b45a1a66b1509f90b7a000/0" class="" title="HEAD1">
<p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p>
<p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的<code>commit id</code>。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">ea34578 HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">3628164 HEAD@&#123;1&#125;: commit: append GPL</span><br><span class="line">ea34578 HEAD@&#123;2&#125;: commit: add distributed</span><br><span class="line">cb926e7 HEAD@&#123;3&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure>
<p>终于舒了口气，第二行显示<code>append GPL</code>的<code>commit id</code>是<code>3628164</code>，现在，你又可以乘坐时光机回到未来了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>现在总结一下：</p>
<ul>
<li>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li>
</ul>
<ul>
<li><p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</p>
</li>
<li><p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p>
</li>
</ul>
<h1 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h1><blockquote><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p>
</blockquote>
<h2 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h2><p>就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：</p>
<img src="http://www.liaoxuefeng.com/files/attachments/0013849082162373cc083b22a2049c4a47408722a61a770000/0" class="" title="工作区">
<h2 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h2><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。<br>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p>
<img src="http://www.liaoxuefeng.com/files/attachments/001384907702917346729e9afbf4127b6dfbae9207af016000/0" class="" title="版本库">
<p>分支和<code>HEAD</code>的概念我们以后再讲。<br>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：<br>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；<br>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。<br>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。<br>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。<br>俗话说，实践出真知。现在，我们再练习一遍，先对<code>readme.txt</code>做个修改，比如加上一行内容：</p>
<blockquote><p>Git is a distributed version control system.<br>Git is free software distributed under the GPL.<br>Git has a mutable index called stage.</p>
</blockquote>
<p>然后，在工作区新增一个<code>LICENSE</code>文本文件（内容随便写）。<br>先用<code>git status</code>查看一下状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Changes not staged for commit:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">#</span><br><span class="line">#       modified:   readme.txt</span><br><span class="line">#</span><br><span class="line"># Untracked files:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">#</span><br><span class="line">#       LICENSE</span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。<br>现在，使用两次命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#       new file:   LICENSE</span><br><span class="line">#       modified:   readme.txt</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<p>现在，暂存区的状态就变成这样了：</p>
<img src="http://www.liaoxuefeng.com/files/attachments/001384907720458e56751df1c474485b697575073c40ae9000/0" class="" title="暂存区变化了">
<p>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure>
<p>现在版本库变成了这样，暂存区就没有任何内容了：</p>
<img src="http://www.liaoxuefeng.com/files/attachments/0013849077337835a877df2d26742b88dd7f56a6ace3ecf000/0" class="" title="暂存区没有任何内容">

<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。</p>
</li>
<li><p>没弄明白暂存区是怎么回事的童鞋，请向上滚动页面，再看一次。</p>
</li>
</ul>
<h1 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h1><p>现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。<br>你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。<br>为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：</p>
<blockquote><p>$ cat readme.txt<br>Git is a distributed version control system.<br>Git is free software distributed under the GPL.<br>Git has a mutable index called stage.<br>Git tracks changes.</p>
</blockquote>

<p>然后，添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#       modified:   readme.txt</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>然后，再修改readme.txt：</p>
<blockquote><p>$ cat readme.txt<br>Git is a distributed version control system.<br>Git is free software distributed under the GPL.<br>Git has a mutable index called stage.<br>Git tracks changes of files.</p>
</blockquote>

<p>提交：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;git tracks changes&quot;</span><br><span class="line">[master d4f25b6] git tracks changes</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<p>提交后，再看看状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Changes not staged for commit:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">#</span><br><span class="line">#       modified:   readme.txt</span><br><span class="line">#</span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p>咦，怎么第二次的修改没有被提交？<br>别激动，我们回顾一下操作过程：<br>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code><br>你看，我们前面讲了，Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。<br>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git diff HEAD -- readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 76d770f..a9c5755 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,4 +1,4 @@</span><br><span class="line"> Git is a distributed version control system.</span><br><span class="line"> Git is free software distributed under the GPL.</span><br><span class="line"> Git has a mutable index called stage.</span><br><span class="line">-Git tracks changes.</span><br><span class="line">+Git tracks changes of files.</span><br></pre></td></tr></table></figure>

<p>可见，第二次修改确实没有被提交。<br>那怎么提交第二次修改呢？你可以继续<code>git add</code>再<code>git commit</code>，也可以别着急提交第一次修改，先<code>git add</code>第二次修改，再<code>git commit</code>，就相当于把两次修改合并后一块提交了：<br>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git add</code> -&gt; <code>git commit</code></p>
<p>好，现在，把第二次修改提交了，然后开始小结。</p>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>现在，你又理解了Git是如何跟踪修改的，每次修改，如果不<code>add</code>到暂存区，那就不会加入到<code>commit</code>中。</p>
<h1 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h1><p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在<code>readme.txt</code>中添加了一行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br></pre></td></tr></table></figure>

<p>在你准备提交前，一杯咖啡起了作用，你猛然发现了“stupid boss”可能会让你丢掉这个月的奖金！<br>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用<code>git status</code>查看一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Changes not staged for commit:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">#</span><br><span class="line">#       modified:   readme.txt</span><br><span class="line">#</span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<p>你可以发现，Git会告诉你，<code>git checkout -- file</code>可以丢弃工作区的修改：<br><code>$ git checkout -- readme.txt</code><br>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：<br>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。<br>现在，看看<code>readme.txt</code>的文件内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure>
<p>文件内容果然复原了。<br><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。<br>现在假定是凌晨3点，你不但写了一些胡话，还<code>git add</code>到暂存区了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure>
<p>庆幸的是，在<code>commit</code>之前，你发现了这个问题。用<code>git status</code>查看一下，修改只是添加到了暂存区，还没有提交：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#       modified:   readme.txt</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<p>Git同样告诉我们，用命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD readme.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       readme.txt</span><br></pre></td></tr></table></figure>
<p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。<br>再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Changes not staged for commit:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">#</span><br><span class="line">#       modified:   readme.txt</span><br><span class="line">#</span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<p>还记得如何丢弃工作区的修改吗？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure>
<p>整个世界终于清静了！<br>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把“stupid boss”提交推送到远程版本库，你就真的惨了……<br>小结<br>又到了小结时间。<br>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。<br>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD file</code>，就回到了场景1，第二步按场景1操作。<br>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 中的 Function 函数</title>
    <url>/2017/06/13/javascript%E4%B8%AD%E7%9A%84Function%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote><p>本文引用的部分链接<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript#内部函数" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript#内部函数</a><br><a href="https://stackoverflow.com/questions/111102/how-do-javascript-closures-work" target="_blank" rel="noopener">https://stackoverflow.com/questions/111102/how-do-javascript-closures-work</a><br><a href="https://translate.google.cn/#en/zh-CN/Local%20variables%20that%20end%20up%20within%20closure" target="_blank" rel="noopener">https://translate.google.cn/#en/zh-CN/Local%20variables%20that%20end%20up%20within%20closure</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Inheritance" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Inheritance</a></p>
</blockquote>
<h2 id="面试题强力分析"><a href="#面试题强力分析" class="headerlink" title="面试题强力分析:"></a>面试题强力分析:</h2><p>记住这天，人生第一次在场笔试失利，虽然是自己在基础方面不够过关，但是我认为前端对于程序员来说，难度最大的还是在背诵方面，需要记忆的东西还是比一般的来说太多了，比如有一题我真的很少用原生的Js的控制Dom的习惯，题目是div自身点击，然后删除自己本身。<br>哇，现在看看真的是简单；笔试的时候没有工具是一件十分恶心的事，对于我来说！<br> <a id="more"></a></p>
<iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/h5eyrL50/embedded/js,html/light" frameborder="0" allowfullscreen></iframe>
<p>还有一题也是比较恶心，不是我觉得它难，而是觉得它让我回到了高考那个看题时代，题目是这样的：让一个div垂直水平居中。</p>
<p>具体可以参考别人的想法<br><a href="http://blog.csdn.net/freshlover/article/details/11579669" target="_blank" rel="noopener">http://blog.csdn.net/freshlover/article/details/11579669</a><br><a href="/img/2017-06-13-img1.jpg">慕课前端面试图片</a><br>第一，我让有点印象这道题，没错就如同高考中可能会遇到类似题型的感觉</p>
<p>第二点，我就想到你这题没有说用css还是js啊，虽然js我可能不会，但是你不说明的话，只能怪我不客气了，我要写css！</p>
<p>所以第三点我就非常气，css写垂直水平居中到底是什么概念啊！我百度了下就是完全处于中心，嗯，这点我懂了，可以用绝对位置去应对<br>先看答案</p>
<iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/ac5wjpvj/embedded/css,html/light" frameborder="0" allowfullscreen></iframe>

<p>垂直居中呢？而且200px与200pxd的宽度呢？这都是wrapper没有高度惹的祸<br>理论上应在根据窗口自适应是最好的，但这肯定要用到js方面的知识<br>这样不是也可以用margin了吗？<br>甚至效果更好不是吗？</p>
<iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/rsk6xu5h/embedded/css,html/light" frameborder="0" allowfullscreen></iframe>

<p>其他都不说了，最气的还是有一题根本没遇到过这样的情况，来当作面题了<br>题目是这样的：<br>利用js代码实现add(1)(2)和add(1,2)<br>题目的思想很明显<br>当你在命令行敲入add(1,2)<br>返回3<br>同样的是add(1)(2)<br>也要返回3<br>这样的写法在任何语言都是一种语法的报错，但是在js就不同了，可以当时的我真没遇到这样的写法，在写项目也没有老师会用这样的写法，真的是日了狗了，好吧，他就是考的是基础<br>然后回到寝室，我开始奋力补习，亲切的打开MDN专业文档<br><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Basics" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Basics</a><br>先盲目补习下对象的知识<br>主要现在是正文真正的开始，js中的function是真的重要</p>
<h2 id="Js中的对象"><a href="#Js中的对象" class="headerlink" title="Js中的对象"></a>Js中的对象</h2><p>空对象的定义十分简单</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name : [<span class="string">'Bob'</span>, <span class="string">'Smith'</span>],</span><br><span class="line">  age : <span class="number">32</span>,</span><br><span class="line">  gender : <span class="string">'male'</span>,</span><br><span class="line">  interests : [<span class="string">'music'</span>, <span class="string">'skiing'</span>],</span><br><span class="line">  bio : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name[<span class="number">0</span>] + <span class="string">' '</span> + <span class="keyword">this</span>.name[<span class="number">1</span>] + <span class="string">' is '</span> + <span class="keyword">this</span>.age + <span class="string">' years old. He likes '</span> + <span class="keyword">this</span>.interests[<span class="number">0</span>] + <span class="string">' and '</span> + <span class="keyword">this</span>.interests[<span class="number">1</span>] + <span class="string">'.'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  greeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name[<span class="number">0</span>] + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实，js中几乎什么都是一个对象，比如</p>
<img src="https://mdn.mozillademos.org/files/13883/person-diagram.png" class="" title="一个简单的对象类">

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myString.split(<span class="string">','</span>);</span><br></pre></td></tr></table></figure>

<p>myString继承了String的split方法<br>还有写DOM的对象这里就不详细地往下讲了</p>
<p>这里讲完对象就不得不讲讲对象中类，类不是js独创，不过在许多语言都用class这个概念，在php，java，c++，c#等等都可以看到<br>class的使用<br>其实就是为了继承，比如</p>
<img src="https://mdn.mozillademos.org/files/13883/MDN-Graphics-instantiation-2.png" class="" title="类对象">

<p>一个Person 类<br>在一个Person的基础上你不仅可以创造一个名为王小波的一个具体人的对象<br>你甚至可以继承Person类去创建一个新的，属于某个更加具体的类，比如老师Teacher()类<br>Student()类</p>
<img src="https://mdn.mozillademos.org/files/13881/MDN-Graphics-inherited-3.png" class="" title="类继承">
<p>其中属性的继承或者方法的重写都是一种很好的代码循环利用，在程序猿的世界，这叫做防止代码冗余，易于别人或自己看懂代码</p>
<p>对象的构造初始化</p>
<p>类的继承</p>
<p>类继承后可以继续创造相应的对象</p>
<img src="https://mdn.mozillademos.org/files/13885/MDN-Graphics-instantiation-teacher-3.png" class="" title="继承后再次对象">
<p>不过在Js是如何处理这类OOP理论的问题呢<br>引用MDN中的一句话，</p>
<blockquote><p>Some people argue that JavaScript is not a true object-oriented language — for example it doesn’t have a class statement for creating classes like many OO languages. JavaScript instead uses special functions called constructor functions to define objects and their features. They are useful because you’ll often come across situations in which you don’t know how many objects you will be creating; constructors provide the means to create as many objects as you need in an effective way, attaching data and functions to them as required.</p>
<p>来自 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object-oriented_JS" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object-oriented_JS</a> </p>
</blockquote>

<p>Js似乎与其他语言不太一样，它并没有class的语法，在es5中，Js利用的是Function这种特殊的函数去代替class类，这在js中叫做构造器函数</p>
<p>其实这里有的跑题了，但还是要稍微讲一下<br>js中比较正规的创建一个类的方法是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造器及其属性定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">a,b,c,d</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 属性定义</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义第一个方法</span></span><br><span class="line">Test.prototype.x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="comment">// 定义第二个方法</span></span><br><span class="line">Test.prototype.y = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="comment">// 等等……</span></span><br></pre></td></tr></table></figure>

<p>一个类的方法定义在外面，方法与类之间加prototype原型这个单词</p>
<p>讲完对象，让我们与内部函数或者说闭包做一下对比<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript#内部函数" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript#内部函数</a><br>这里它举例到有一种闭包的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = makeAdder(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> y = makeAdder(<span class="number">20</span>);</span><br><span class="line">x(<span class="number">6</span>); <span class="comment">// ?</span></span><br><span class="line">y(<span class="number">7</span>); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>这里不是直接告诉我们答案了吗<br>这里的makeAdder(a)(b)<br>肯定是可以<br>所以这道面试一下子就可以解决了</p>
<p>其实这种写法叫做“柯里化”（’currying’）<br><a href="http://www.ruanyifeng.com/blog/2017/03/ramda.html" target="_blank" rel="noopener">What’s the currying?</a><br>也就是所有多参数的函数，都可以默认单参数去使用。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017030903.jpg" alt="currying"><br><em>这是一种Javascript函数式编程种最理想的工具库</em></p>
<iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/f2L52x0f/embedded/js/light" frameborder="0" allowfullscreen></iframe>

<p>让我们无聊一把，如果参数无数呢？<br>就是add()()()()()()…和add(1,2,3,4,5,6,7,8,….)<br>这样的问题，如果下次面试是这个怎么办？<br>很明显，第二个还是很好解决的，第一就是要用到循环调用函数的问题了</p>
<iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/5rnnfp7k/embedded/js/light" frameborder="0" allowfullscreen></iframe>

<p>函数中循环调用子函数，直到没有()，也就是函数的调用，返回最终x的值</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>前端</tag>
        <tag>柯里化</tag>
        <tag>currying</tag>
      </tags>
  </entry>
  <entry>
    <title>我对自己的一些认知</title>
    <url>/2017/04/08/%E6%88%91%E5%AF%B9%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E7%9F%A5/</url>
    <content><![CDATA[<blockquote><p>现在写这篇文章的时候，我已经大三，也就是即将进入大四的时间段。<br>对这三年而言，我虽然目标不定，但是一直都在做自己喜欢做的事情，大一的时候学学C语言，去集训队参加过一些小型比赛，不过Acm这类算法毕竟有些枯燥，也只是笔头的练习你的动脑能力，所以我在这个原因和我学的硬件的情况下我退出了这个强大的队伍。</p>
</blockquote>
 <a id="more"></a>
<h1 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h1><p>大一的我依然对美有过追求，在大学的记者团出过好几张板报，而且不仅仅能在记者团，参加过的社团几乎都让我出版报。当然这种板报这是PS这类软件做的喽，不是手绘这种我看起来比较累人的活。毕竟我从小画画的基础在大学我看完全丧失了吧…</p>
<p>这是我第一次用<code>PS</code> <code>PhotoShop CS6</code>按照学长的要求去做的海报，当这个海报真的被打印出来的时候真的很开心</p>
<img src="http://o7gvvpsa6.bkt.clouddn.com/17-4-8/25322035-file_1491624074076_1044f.png" class="">
<img src="http://o7gvvpsa6.bkt.clouddn.com/17-4-8/49530355-file_1491624258267_9dbb.png" class="">
<img src="http://o7gvvpsa6.bkt.clouddn.com/17-4-8/61311748-file_1491624804026_4866.png" class="">
<img src="http://o7gvvpsa6.bkt.clouddn.com/17-4-8/12633043-file_1491624860015_1424c.png" class="">
<img src="http://o7gvvpsa6.bkt.clouddn.com/17-4-8/92746422-file_1491624865642_3b28.png" class="">
<img src="http://o7gvvpsa6.bkt.clouddn.com/17-4-8/61746514-file_1491624991892_6465.png" class="">
<blockquote><p>最后一张应该是结束之作吧.渐渐任务变得重复了，不在存有一点新鲜感了，选择在大二时候隐退。</p>
</blockquote>
<h2 id="做了还有很多不是记者团的海报，这里有的找不出来就不发了。我记得有次很自豪的还对室友说，你看啊，这些-手在空中飞舞-海报都是我做的呢-整个学校的海报都是出自我之手，-那时真的特别开心，而且真的有3张海报同时挂在学校的各个地方"><a href="#做了还有很多不是记者团的海报，这里有的找不出来就不发了。我记得有次很自豪的还对室友说，你看啊，这些-手在空中飞舞-海报都是我做的呢-整个学校的海报都是出自我之手，-那时真的特别开心，而且真的有3张海报同时挂在学校的各个地方" class="headerlink" title="做了还有很多不是记者团的海报，这里有的找不出来就不发了。我记得有次很自豪的还对室友说，你看啊，这些(手在空中飞舞)海报都是我做的呢!整个学校的海报都是出自我之手，(那时真的特别开心，而且真的有3张海报同时挂在学校的各个地方)"></a>做了还有很多不是记者团的海报，这里有的找不出来就不发了。我记得有次很自豪的还对室友说，你看啊，这些(手在空中飞舞)海报都是我做的呢!整个学校的海报都是出自我之手，(那时真的特别开心，而且真的有3张海报同时挂在学校的各个地方)</h2><p>除了在记者团，我还在当初所为的艺术团待过，那边也是活力四射的社团，学生都在拼命的展示自己的才艺，一天到晚。当然我并没有什么才艺，最多的时候也只是碰碰单反，拍拍视频，管理搭建微博墙，谁叫我们是媒体部呢!不过长得美的人果然很多在那儿，不过也不排除这个社团本身人就很多，占了学校的1/3的人。</p>
<p>所在我在那儿也结交了一些会做视频的人群，自己也会一些PR，AE技术.做过微电影<a href="http://v.youku.com/v_show/id_XMTI2Mzk2OTU4NA==" target="_blank" rel="noopener">《光》–这是不讲爱情的故事，但是是爱让TA们俩相遇</a></p>
<img src="https://r1.ykimg.com/054101015580CA7F6A0A4504E535C039?_=6681611" class="">
<p>同样欢迎大家能来我的<a href="http://i.youku.com/zhangchao564265135/" target="_blank" rel="noopener">优酷视频站</a></p>
<h1 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h1><p>总该学点有用的知识了吧，毕竟我感觉我们专业的方向不太明确，也不能坐着等屎吧…</p>
<p>除了进入了我们学院的大学生科技创业中心，也同样在老师的推荐下当了个假的<code>OJ</code>管理员，不过当了之后学长讲的东西也是启发了我该学什么语言，因为OJ是用PHP写的所以慢慢去学了，学了之后在中心的能力比别人倒是强了不少，毕竟PHP写网站的速度很快，语法简单，易于学习.不想<code>JAVA</code>，<code>C#</code>不仅<code>IDE</code>超大，复杂，每次的使用要引用对应的包。</p>
<p>可以说是在中心的熏陶下，我发现自己与他人与众不同之处了，而且在中心，这里他们不约束学生的想法，想做就去做，会给你支持，会有很多人来帮助你测试你的项目，是你的项目更加顽健.指导老师也十分支持我，比如不用来一些浪费你时间的会议，别人不可以，我却可以，这让我更加觉得这里是我能够充分发挥我的想法的地方。</p>
<p>所以我会经常推荐学弟学妹们来我们中心，这里不会像学生会那样严格，约束，提供了很好的环境。</p>
<p>就这样，我依靠当时的对web的知识，完成一个简陋的项目(在现在看来，这个项目真是有好看的外表，不堪入目的内部结构，我现在都不想再去修改它了，它简直不可理喻，难以维护)</p>
<p>它叫报名管理系统，基于<code>Tp3</code>搭建的.</p>
<img src="https://raw.github.com/Lanseria/mm/master/docs/images/index.png?_=6681611" class="">
<ul>
<li><a href="https://github.com/Lanseria/" target="_blank" rel="noopener">GITHUB</a></li>
<li><a href="https://www.limonplayer.cn/" target="_blank" rel="noopener">LimonStudio个人主页</a><h1 id="大三"><a href="#大三" class="headerlink" title="大三"></a>大三</h1></li>
</ul>
<p>我进了硬件实验室 叫 电类实验室，那里的牛人也多，有个学长进大疆我记得。</p>
<p>不过我还是应为那里的设备很少，实验室很远，来去不方便，管理松散，为自己找理由吧.现在已经不去了，不过大三开始前暑假有在呆在那儿一会儿过，那边有个马哥算是比较熟啦，他人缘好广，前几个月也找到自己的另一半啦(羡慕// _ //)我和他为老师(是另一个实验室(物联网)的老师做过<code>zigbee</code>的项目，叫做所有权的转换，也算是完成了3个专利吧.然后我就退了，因为也是任务重复度太高，没了兴致。</p>
<p>你可能会问，我怎么不去利用设备去玩转下物联网呢?毕竟这个也是比较火的方向.我想过，不过就目前而言，我也不想毫无头绪，还是先从事软件的行业比较稳妥，另一个就是硬件比较烧钱，作为学生的我还是看看就好….对，怂了。</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>ME</tag>
      </tags>
  </entry>
</search>
