<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vscode开发技巧-远程利用linux开发]]></title>
    <url>%2F2019%2F08%2F09%2Fvscode%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7-%E8%BF%9C%E7%A8%8B%E5%88%A9%E7%94%A8linux%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[前言 此篇文章需要你掌握有关 Git | Vscode | Bash 的基础知识。阅读时长约为5分钟。 作为程序开发者，平时开发我想大多数都是在 Windows 上开发的，如果平时也不会接触计算机中高级的成分，我想你也不需要用到 Linux 等一些系统，其他编译问题可能会遇到，但百度一下都能够解决掉。所以这篇文章自认为是给那些需要装逼，或者需要更不易出错，需要更快的编译时间等那些人看的，在我看来， Linux 上编译的速度远远比 Windows 高得多，所以我开始将开发工作搬运到了 Linux 机器中，一来，我的电脑不会太卡，可以继续流畅地浏览网页。二来，开发速度得到了快速的提升。如果你对此有兴趣的话，我们就马上开始准备吧（这里只讲 vscode 编辑器的远程开发配置） 准备 Vscode 编辑器(我用的是1.37版本) Git windows 安装包 (我的用是git version 2.22.0.windows.1) 以及一些Vscode关键词用来搜索(remote是搜索关键字) 红框是必须要安装的哦，其他也推荐安装，万一没成功我可不知道😂。 配置安装完这些插件之后，这时你可以看到你的左侧会多一个PC的图标 点开之后会出现类似截图一样的链接(不过这些链接一般是不可能链接成功的) 你可能会问，为什么我没有你出现的这四个链接，因为我git的ssh目录做了配置，这也是我为什么发现这样的可行性。如何打开你的ssh配置？只要右击打开git-bash命令行输入 code ~/.ssh/ 即可 如果是我的话会打开这样之前已经被我配置过的 config 文件，如果你是空白的话，你需要自行创建一个config文件，如何创建我在之前的文章已经提过，你可以直接翻看的文章进行理解与配置 相关SSH配置链接 然后开始填写你Linux ssh配置, 这些配置信息如何来，看上面链接上的文章即可，你需要知道你的服务器的IP地址, sshkey 域名(没有可以利用hosts配置) 1234567#txsshcqHost ivhik.cn # 域名(绑定你的服务器IP) Port 22 #端口 HostName ivhik.cn StrictHostKeyChecking no IdentityFile ~/.ssh/id_rsa_ssh # 你的私钥 User root #你的登陆用户名称 配置之后，还需要移除 Windows 自带的 ssh需要管理员运行 1Remove-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0 然后将 git 的 /bin 目录添加在 windows path 环境变量中 接下来你就可以远程编辑你服务器里的代码了]]></content>
      <categories>
        <category>技术</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Vscode</tag>
        <tag>remote</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 分支名的一些见解]]></title>
    <url>%2F2018%2F12%2F28%2Fgit-%E5%88%86%E6%94%AF%E5%90%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%81%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言 此篇文章需要你掌握有关 Git | CMD | Bash 的基础知识。阅读时长约为5分钟。 首先说说为什么会写这篇文章。公司可以很少人真正能够了解 Git 分支管理流程，命名也是一团糟，原因也十分简单，大家都是从 SVN 转移过来的，这种单纯的文件保存系统，就跟 IDEA，STS 的文件历史系统保管一样，简单，理解起来容易，但是与 Git 的所具有的功能差别就大了，Git 就是来解决项目中的多人同步开发的问题，合理的分支管理甚至能够帮助你查错与排错，高效地二分查找命令等等。所以这篇文章就是来讲明白甚至提出自己的一些见解来让公司的项目更加的快速迭代与开发。 分支 分支在 Git 中是非常重要的一个知识点， Git 的所有命令都是围绕这个操作的。 通常情况下, 分支一般只会存在下边几种情况: master：与线上版本保持绝对一致； develop：开发分支，由下文提到的 release 、 feature 、 hotfix 分支合并过后的代码； feature：实际功能点开发分支，建议每个功能新建一个 feature ， 具有关联关系的功能公用一个 feature 分支； release：每一次开发完成之后，从 develop 创建出来的分支，以此分支为基准，进行测试； hotfix：该分支主要用于修复线上bug； refactor：需要大量重构(公司不存在架构师的情况下)； 命名规范约定如下： feature分支命名：feature/name release分支命名：release/name hotfix分支命名：hotfix/name 比如有一个「优化分布式Session」的需求，可在develop分支的基础上创建新分支 feature/optimize_distributed_session 进行开发，开发完成后合并到 develop 分支。 分支详细介绍和处理流程master分支主分支，与线上运行的版本始终保持一致，任何时候都不要直接修改master分支。 一个版本的release分支、hotfix分支开发完成后，会合并代码到master分支，也就是说master分支主要来源于release分支和hotfix分支。 develop分支开发分支，始终保持最新完成以及bug修复后的代码，新增功能时基于该分支创建feature分支。 一个版本的release分支、hotfix分支开发完成后，也会合并到develop分支，另外，一个版本的feature功能开发完成后，也会合并到develop分支。也就是说develop分支来源于feature、release、hotfix分支。 feature分支开发新功能或优化现有功能时，会创建feature分支，以develop为基础创建。一般会有多个功能同时开发，但上线时间可能不同，在适当的时候将特定的feature分支合并到develop分支，并创建release分支，进入测试状态。 release分支当一组feature开发完成，会首先合并到develop分支，开始进入提测阶段时，会创建release分支。 以release分支代码为基准提测，测试过程中若存在bug需要修复，则直接由开发者在release分支修复并提交。 测试完成之后，合并release分支到master和develop分支，此时master为最新代码，用作上线。 hotfix分支线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支，修复完成后，需要合并到master分支和develop分支。 特殊情况处理和注意点develop分支已存在未上线的feature代码, 此时需要紧急上线一个新功能, 但develop的代码不能上，如何处理 ？ 以master为基线创建feature， 在完成之后，代码合并到master分支；为了保证develop是最新代码，需要从master合并到develop分支； 以develop为基线，创建了f1和f2两个feature分支之后, f1,f2开发一半的时候，发现两个分支代码需要有依赖怎么办 ？ 最好在开发开始前确定两个功能是否相关,若相关则只创建一个分支,两个功能在一起开发;如果已经创建，则需要合并到一个分支； 保证 commit 整洁一定要保证commit历史记录的整洁，代码合并时，根据情况选择merge或rebase;使用rebase注意，一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作；提交说明规范： 提交说明最好限制在一行以内，50个字符以下，简明扼要地描述更新内容，空开一行后，再展开详细注解；如果关联jira，写上jira地址； 借鉴文章作者：情情说链接：https://juejin.im/post/5aa7e8a6f265da239f070d82来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 线下最好用CMD命令行操作一下]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Branch</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node的一些基础知识]]></title>
    <url>%2F2018%2F11%2F11%2FNode%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[前言 此篇文章需要你掌握有关 Node.js | javascript | CMD | Bash 的基础知识。阅读时长约为5分钟。 快半年没有在这里写东西了，这次就简单讲讲 Node.js 的一些必要知识，方便刚学习的人跨过一些坑。首先来看看 Node.js v10.13.0 又更新了什么功能。 Node v10.13.0 更新对我来说一下几点有比较大的改动： npm-gyp 等一系列工具的安装选项要知道，以前如果没有全局安装这些编译环境的话，有些好用的包是用不了的，经常会报错，安装失败（毕竟 Node.js 也需要外来编译成的帮助）。现在你只需要安装Nodejs时，勾上这个选项， Nodejs 就会在安装完 Nodejs 之后帮你安装全部的编译环境，免去失败的或者安装不全的烦恼。 V8 已升级至 6.6 版本。 OpenSSL 升级至 1.1.0h 版本。 新增 console.table() 方法。 crypto.createCipher() 和 crypto.createDecipher() 方法已被弃用，并被 crypto.createCipheriv() 和 crypto.createDecipheriv() 替代。decipher.finaltol() 方法已弃用。crypto.DEFAULT_ENCODING 属性已弃用。新增 ECDH.convertKey() 方法。crypto.fips 属性已弃用。 NPM 包的使用这里不多说，国内镜像三步走。 123npm set registry https://registry.npm.taobao.orgnpm set disturl https://npm.taobao.org/distnpm i -g mirror-config-china --registry=https://registry.npm.taobao.org NPM 和 Yarn 的区别虽然大家都是包管理工具，但 yarn 的安装速度的确不必 npm 慢，可以这么说， yarn 是一种实验性质的包管理，它具有大家先进的理念与想法。最近 yarn 好像又推出了像 java maven 一样的包管理形式，让包不直接放在项目文件夹这么占用地方，放在公共的本地仓库会使更佳的解决办法。 .lock 文件如果你在国外，这个不用操心，但是你在国内，还是希望你在 git 项目中能够移除这样的包锁定文件，这可能导致你的自动化集成失败，原因就是你用的是国内的镜像，国外访问是过慢的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>NPM</tag>
        <tag>镜像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH密钥，一个钥匙走天下]]></title>
    <url>%2F2018%2F03%2F07%2Fssh%E5%AF%86%E9%92%A5%EF%BC%8C%E4%B8%80%E4%B8%AA%E9%92%A5%E5%8C%99%E8%B5%B0%E5%A4%A9%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[前言 此篇文章需要你掌握有关 ssh-key | linux | git配置的基础知识。阅读时长约为5分钟。 前几天，我在腾讯云用 ssh 配置完登录密钥后，才发现 ssh config 文件并不是必须的，你确保你的 ssh key 私钥能不被泄露的话，或者即使泄露成本也很低，我就推荐你这样做。是真的很方便，只要你随手拿着你的唯一的 ssh 私钥就可以了。 不用一个私钥的方法 比如你经常用到 github ，你就需要随时 push and pull 仓库的代码。 同时你公司还要用到 gitlab 的仓库，于是这个坑就出来了。如果你当时什么也不懂，你在为创建 gitlab 的 ssh key 时，你就会覆盖掉原先的 github 的 ssh key 所以你只能在其中选一个。 解决方案也有，就是在 ~/.ssh/ 下创建一个 config 文件，配置相应信息，让 ssh 能够通过配置去访问不同的私钥，通过拿着不同的私钥去 pass 不同网站仓库严格的验证 validate config 文件 参考 1234567891011121314151617181920212223#oschina Host git.coding.net HostName git.coding.net IdentityFile ~/.ssh/id_rsa_coding PreferredAuthentications publickey User youemail@qq.com#githubHost github.com HostName github.com IdentityFile ~/.ssh/id_rsa_home PreferredAuthentications publickey User youemail@qq.com#gitlabHost gitlab.com HostName gitlab.com IdentityFile ~/.ssh/id_rsa_cpn PreferredAuthentications publickey User youemail@qq.com#txsshHost 115.159.27.203 StrictHostKeyChecking no IdentityFile ~/.ssh/id_rsa_ssh 这个配置如果你需要通过 ssh 登录 linux 的话，看最后一个配置就可以了，就可以实现无密登录 实现一个私钥走天下 只要你在一开始就生成一个私钥和公钥就可以了，以后 github 或者 gitlab 再者 linux ssh key 都使用同一个公钥文件就可以实现了。 你不需要再配置 config 了，或者在另一台电脑上再去配置 ssh-key 使你的 key 管理不过来]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>ssh-key</tag>
        <tag>密钥</tag>
        <tag>登录</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年，新年快乐，定个小目标]]></title>
    <url>%2F2018%2F01%2F01%2F2018%E5%B9%B4%EF%BC%8C%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%8C%E5%AE%9A%E4%B8%AA%E5%B0%8F%E7%9B%AE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[今年的2018还是跟以前一样，一个人的跨年，一个人的节日，在此，争取在下个元旦能够找到一个女票，如果这一年比较忙的话，会孤独惯了，那就真的随天命勒。 总结过去一年，发现大学的生活已经离我而去，每次去学校都带有陌生的感觉，熟悉的人已不再经常碰到，满是新生的气息。所以带有恐惧感靠近学校也想早点离开这个地方，这个在我眼中的象牙塔。 2018年还是一个变化比较大的一年： 比特币从今年开始被大众关注，特别是5月12日，比特币勒索病毒WannaCry，让人们认识到这种黑客货币的存在。这是比特币的一年。 不过同时也是人工智能的一年：5月27日，柯洁以0:3败给AlphaGo，泪洒当场。之后的一次网上对剧中，击败众多选手，让人工智能这个词语放大，之后火起来的不管是深度学习还是大数据都吸引人们的眼球。 当然作为果粉也不会忘记今年的苹果公司在手机上转型的一年。可以看到异性屏的发布与A11芯片的加入，神经网络的学习在未来越来越重要了。 还有很多很多，这里就不再一一赘述。 世界发生着改变，同样我觉得一个人一年内世界观不与时俱进的话，我认为他可能过得也太舒服了。下面也总结的我的世界观的变化： 在感情上：我觉得更加奔放了。对一些难以说出口的词语也不嫌而避之。不怕被别人说自己很不纯。不过这些还是要在适当场合说说。另外，这一年也是觉得感情的哪一方都应该去理解下对方的感受。在今年七夕节被一个追了我2年的女孩又告白了。她喜欢用酒去避讳这写尴尬的语境，所以那晚我被缠了1个小时。。想想是有点可怕但是还是跟她继续聊下去，希望她能知道。对于她，我认为她的勇气真的非同常人，所以我也希望今后她的感情能够一直那么勇敢，我是不想打断她的积极性的。还有就是缘分，缘分尽了就真的没有什么好讲了。一个人不喜欢，就是真的不喜欢，即使让她依让她抱，都是安慰她。会想起高中三年一直有暗恋的对象。虽然感觉也是先被送礼物的，但是没抓住就是后悔，到现在就是无怨无悔，即使现在她有些电脑上的问题问我，我心里也没有像以前一样追在她后面，默默看她进一条街巷，回住的地方，没有那种一看就是几分钟，一想就是满满欣慰的体会了。所以，现在的我还是一如既往的学习这些，多跟女性朋友聊天，问问题。希望在真的遇到自己能爱的人，能够全心全意对她。 生活上：开始注重身体，作为一名程序员，没有好的身体就没有人生。我会加油，在今年能够在锻炼上有所突破。 金钱上：我在今年如实找到了一份工作，住的还行，人到很少，就我和技术主管两个人了。买了新手机和新手表用来锻炼。开始注重工具带来的效率。希望下一年能够买个台式可以玩玩游戏，买个苹果电脑来敲敲代码。同时希望下个月就能涨工资，顺便问问实习什么时候结束，我在公司以后的职业前景会是如何。 最后呢，我写个择偶标准吧。看看下年会不会将低许多。人好是第一位；有学习能力，不路痴；勤快的家伙，有娱乐游戏的爱好；如果额外技能如会跳舞，会唱歌就更好了； 应该要求不过分吧。。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>目标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VsCode编辑器的设置技巧（JavaScript格式化篇）]]></title>
    <url>%2F2017%2F12%2F22%2FVsCode%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E8%AE%BE%E7%BD%AE%E6%8A%80%E5%B7%A7%EF%BC%88JavaScript%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言作为一个IT工作者，不管你是前端还是后端，甚至是大数据分析师，只要你接触代码，你总会要去选择一款方便的编辑器来配合你的工作。 我这里来列举下通常情况下各个编辑器会被哪类人使用 C++/C 入门者：CodeBlocks、 DevCpp、 Vc6++Java : ecilipse、 IntelliJ IDEAPython: PyCharmHTML等前端: HBuilder通用编辑器: Sublime、 Atom、 vsCode 有一款好用的编辑器或者说是工具，就是一个IT工作者很好的利器，但是光有还不行，你至少要学会如何配置它，但是如果你还有额外的经理和能力，工具是开源的情况下，你就可以升级它。把他变成你所想要的模样。 格式化的重要性 格式化是一个程序员的基本素养，我看过那些换行都懒得换的，写出来的样子都没有左对齐，简直难以审阅 有良好的格式化能力，不仅帮你审阅代码时不疲劳，甚至可以减少代码出错的概率 从而帮你平常的一些小痛苦中解脱出来 编辑器的选择编辑器，我这里还是以我在工作上的角度去编写，以 VsCode 配置来说一下 Format 技巧 不过还是要说说它的优点相比大多数大型 IDE 而言，它的功能单一但是速度很快相比 ATOM 等自由度甚高的来说，它稳定性高而且依赖群体人数多 VsCode配置举例解说如果你是经常用 javscript 写项目的话，你会发现 eslint 的配置和 VsCode 的格式化有一些些冲突特别当你复制下面这一段代码时 12345export function saveWorkbook (xlsxName: string, wb: XLSX.WorkBook) &#123; /* write workbook (use type 'binary') */ const wbout = XLSX.write(wb, &#123;bookType: 'xlsx', type: 'binary'&#125;) saveAs(new Blob([s2ab(wbout)], &#123;type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'&#125;), xlsxName)&#125; 这段代码在普通的 eslint 下是不会报错的，但是如果你将它复制一下，他就可能格式错乱了 12345export function saveWorkbook(xlsxName: string, wb: XLSX.WorkBook) &#123; /* write workbook (use type 'binary') */ const wbout = XLSX.write(wb, &#123; bookType: 'xlsx', type: 'binary' &#125;) saveAs(new Blob([s2ab(wbout)], &#123; type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'&#125;), xlsxName)&#125; 当然不同的人，有不同的配置，这里不岔开去讲了 这里有亮点不同，我分别用中文与英文，还有我自己的理解去说 saveWorkbook(xls:saveWorkbook (xls这个区别官方叫做 在函数参数括号前定义空格处理英文写法是 insertSpaceBeforeFunctionParenthesis其实英文的写法更好理解一些，叫做在方法名后参数列表前插入空格 XLSX.write(wb, {bookType: &#39;xlsx&#39;, type: &#39;binary&#39;})定义非空括号的左括号后面和右括号前面的空格处理英文简写 insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces以我的定义就是前大括号之后的空格与后大括号的空格加不加的问题 其它还有很多，我就不累述了，因为 Vscode 在翻译上做的挺不错的]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>VsCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一直在督促别人学习，但知道这是无用功。直到他们走到这一步]]></title>
    <url>%2F2017%2F12%2F13%2F%E4%B8%80%E7%9B%B4%E5%9C%A8%E7%9D%A3%E4%BF%83%E5%88%AB%E4%BA%BA%E5%AD%A6%E4%B9%A0%EF%BC%8C%E4%BD%86%E7%9F%A5%E9%81%93%E8%BF%99%E6%98%AF%E6%97%A0%E7%94%A8%E5%8A%9F%E3%80%82%E7%9B%B4%E5%88%B0%E4%BB%96%E4%BB%AC%E8%B5%B0%E5%88%B0%E8%BF%99%E4%B8%80%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[男女真的大多时候不是同一世界里的，虽然我遇见过女生最后选择了程序员，但刚开始走的路远比男生艰辛。可能是 C 语言语法没学好等等，不管怎样，基础就差了一个档次。 可能有人会说前端容易啊！对，前端是容易的，但这也只是在前几年，现在的前端，你没有一定的面向对象的基础，你根本是很难学懂的。 这篇文章是写给计算机专业的女生看的 回过头写：如果有计算机女生大触看，我这里说一句：“打扰了！打扰了！打扰了！” 如果你真的不喜欢计算机，我还是劝你迟早放弃，找点设计或者你所喜欢的职业去试试，兴趣第一，这句话我一直存在我的口中。 但是我想，能选择计算机专业的女生，大多数还是对它有点喜欢的，至少认为它有点用，也是因为其它的专业我也不喜欢。。 的确，学好计算机你可以做许多工作，现在那个人不会计算机呢？当客服，你可以通过计算机查询问题来回答客户的问题；当会计你至少要学会Excel去统计数据吧；等等，最后如果你什么都不会，至少打打字也能赚点外快。 不过这些都是比较容易的职业，前景与方向都是不明朗的，不知道哪天AI出来就把这些职业代替掉了。所以学习计算机，当然是要充分理解计算机的原理，做个比一般的角色，当个有知识深度的人。至少至少，当你使用你每天都会打开的APP时，用PC端的QQ跟别人聊天时，上网站逛淘宝京东时，甚至锻炼打电话等等，我希望你能思考思考这些到底是怎么实现的。你可能会问，我为什么要知道这些东西，我想说的是，一，你每天都在接触的东西，都是依赖你现在所学的知识，体系，两者之间，如果你有很好的融汇贯通，你会对老师教的，课程视频里岔开来讲的问题有更深刻的理解；二，对以后自己做项目时，有更好的参考依据，就拿个比方来讲，最简单都是造轮子了，你想写个类似QQ的聊天项目（以后好方便找工作拿得出手）那你不仅平时要仔细观察QQ的界面组成，怎么改用代码写出来，还要观察通信方式是怎么实现的，如何实现，还是得靠你们现在已有的经验去推测。 所以平时多想问题的你，就与之前只会刷刷微信聊聊天的你产生了差别，兴趣也就可能从此产生。如果你对的说法没有大的感触，那你可能真的不想知道，可能计算机的这条路是不太适合你的，探索的精神是必须要有的。 光有探索精神还不够 探索只是给与你激发兴趣的方法，光想，光理论是远远不够的，这也是大部分女生到大学的学习计算机时的通病，看过我们的班的女生写个物理实验报告，整整地把A4纸两面都写满了，我当时脑中真是懵逼的，“哪来的那么多字？？？”，“哪里来的时间？（可能我偷偷打游戏的时候）”，“字写得这么好，一定很累吧。。”我看着自己简简单单的那几个字，真是心中有些敬仰了。 不过这都是题外话，我高中好多人也是这样的，我也是尽力做这么多，毕竟老师要检查笔记嘛！ 但是，学习计算机不一样，我们不一样🙃。刚开始，的确还是可以写写笔记，练练书法之类的。但是你到以后，真的记得过来嘛！ 计算机的知识体系与其他有很大不同 计算机，代码要求很高，错一个字母都不行 要记得代码方法甚多，一个语言的文档都几千页，根本难以用手写记录 英文很重要，充分理解计算机系的英语，对学习计算机有很大帮助 计算机唯一记忆不多而且可以略略而记的就是算法 提升编程能力方式：多敲代码，多看别人写的代码，多看新的代码 应该还有很多，我这里只是以我的角度来看，也就是这几点，我观察过，大部分女生都难以做到（因为我教了 3 届的学弟学妹） 在这里呢！我举几个例子，看的的可以对号入座下： 我班11个女生，没见过她们参加什么代码比赛，毕竟硬件专业，因为这对于他们来讲更需要动手能力。代码课似乎都只是按着代码敲敲，没有参加实验室之类的活动。 慧慧，一个计科班的女生，似乎参加过acm比赛，和培训，数据结构和算法的课都上的比我多，毕业算作是合格了，也跟我一起参加过计算机设计大赛。但是动手能力只能说一般，没有真正敲过一个项目，参与似乎也没有，练的最多也就是小例子，小Demo，入门教程，什么都是入门，对游戏也是比较吸引力，不过不会理财（这个就叉开话题了…），但是还是一样，笔记我看她还是手写，或者用word写，考试最后复习的时候也是。 另一个慧姐，也是同届计科班的学生，和团队参加过很多ACM比较，远比我厉害，英语过了四六级，上一个慧姐也是，担任着团支书，目前似乎准备着考研，好像她还参加过数学建模比赛，同样都是巨蟹座，不过，这样的过程，没有编程语言上的积累，似乎她的方向也很明确了，考研做研究方向，以后出国都是吃很有可能的，所以这是我们这等人学不来的，毕竟人家理论已经高到了另一个层次。 我带过的一个政法的一个15妹子，当初她跨界来学php也是让我感动，但最后还是没有坚持，估计技术的门槛还是拦住了她，因为我看到她的电脑还是旧的，估计是哥哥姐姐给的，学习计算机，电脑，笔记本是最基础的东西，那东西如果你没有过多要求，也就反映了你对计算机这门技术不当回事，我们都有计算机太卡，想砸电脑冲动的时候。 一个在暑假遇到的学妹，蒋柯，但是她带给我的感觉就是有那股学习的冲劲，有时上午结束后都是最后一个走，有时也会问问学长问题，问题也是自己尝试多边的问题，给我说了很多想法，这如果我再不帮她解决问题实在是说不过去了。现在她到实验室了，估计会有所作为吧。 当然也有很有潜力但还没遇到紧要关头，16级的王莉莉，她跟我说，对学什么都不太感兴趣，但要求她去做的事，她总能完成的很好，有很好的审美观，也与大家做出来的东西不太一样，不过个人还是比较腼腆，不擅长说话，不过似乎也说得过去。 其它的我也不多说了，很欣慰看到有的女生会装机了，会重装系统了，这种大胆的尝试都是非常有必要的，毕竟你比别人多了一项技能。 结尾催催催还是没有用的，只有自己即将毕业的时候，后悔大学没能干成什么事，就像我姐，大学里还是天天拿奖学金，但是出了社会才知道险恶，从金融业毕业，你没有实践能力，最后还不是只能当当柜员，帮银行拉点钱，比不了外面有钱的人的，只有自己掌握了足够的技术，别人才会要你，甚至花钱买你。]]></content>
      <categories>
        <category>日志</category>
        <category>软文</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[single-transition-timing-function-单个过渡式时序函数]]></title>
    <url>%2F2017%2F11%2F06%2Fsingle-transition-timing-function-%E5%8D%95%E4%B8%AA%E8%BF%87%E6%B8%A1%E5%BC%8F%E6%97%B6%E5%BA%8F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[引用英译 这个单调式时序过渡函数是一种 CSS 数据类型，用于表示在整个一维动画期间，相应的值变化多快的数学函数。可以让你在整个持续时间内通过建立各种不同的数学函数来控制数值的速度。 “平滑”定时功能通常被称为 easing 函数。 他们将时间比率与输出比率相关联，均表示为。 对于这些值，0.0代表初始状态，1.0代表最终状态。 根据所使用的具体功能，在动画过程中，计算的输出有时可能会增大到大于1.0或小于0.0。 这会导致动画比最终状态更远，然后返回。 对于某些属性，如左或右，这会产生一种“弹跳”效果。 但是，某些属性会超出允许的范围限制输出。 例如，大于255或小于0的颜色分量将被剪裁到最接近的允许值（分别为255和0）。 一些 cubic-bezier() 曲线显示此属性。 Timing functionsCSS支持两种定时功能：作为函数的三次贝塞尔曲线的子集，以及阶梯函数。 这些函数中最有用的是给出一个关键字，使他们可以很容易地引用。 The cubic-bezier() class of timing functions cubic-bezier() 函数表示法定义了一个三次贝塞尔曲线。 如这些曲线是连续的，它们通常用于平滑向下的开始和动画的端，因此有时被称为缓和功能。 三次贝塞尔曲线由四个点P0，P1，P2和P3限定。 P0和P3是曲线的开始和结束，在CSS中，这些点是固定的，因为坐标是比率（横坐标是时间的比率，纵坐标是输出范围的比率）。 P0为（0,0），表示初始时间和初始状态，P3为（1,1），表示最终时间和最终状态。 不是所有的三次贝塞尔曲线适合作为计时功能，因为不是所有的数学函数; 即对于给定的横坐标具有零个或一个值的曲线。 与P0和P3固定由CSS如所定义的，三次贝塞尔曲线是一个函数，因此是有效的，当且仅当P1和P2的横轴都在[0，1]的范围内。 P1或P2纵坐标在[0,1]范围以外的三次贝塞尔曲线可能会产生弹跳效果。 当你指定一个无效的三次贝塞尔曲线时，CSS会忽略整个属性。 Syntax 1cubic-bezier(x1, y1, x2, y2) x1, y1, x2, y2 值代表横坐标，P1和P2点的纵坐标定义三次Bézier曲线。 x1和x2必须在[0，1]范围内，否则该值无效。 ExamplesThese cubic Bézier curves are valid for use in CSS : 1234567891011/* The canonical Bézier curve with four &lt;number&gt; in the [0,1] range. */cubic-bezier(0.1, 0.7, 1.0, 0.1)/* Using &lt;integer&gt; is valid as any &lt;integer&gt; is also a &lt;number&gt;. */cubic-bezier(0, 0, 1, 1)/* Negative values for ordinates are valid, leading to bouncing effects.*/cubic-bezier(0.1, -0.6, 0.2, 0)/* Values &gt; 1.0 for ordinates are also valid. */cubic-bezier(0, 1.1, 0.8, 4) These cubic Bézier curves definitions are invalid : 1234567891011121314/* Though the animated output type may be a color, Bézier curves work w/ numerical ratios.*/cubic-bezier(0.1, red, 1.0, green)/* Abscissas must be in the [0, 1] range or the curve is not a function of time. */cubic-bezier(2.45, 0.6, 4, 0.1)/* The two points must be defined, there is no default value. */cubic-bezier(0.3, 2.1)/* Abscissas must be in the [0, 1] range or the curve is not a function of time. */cubic-bezier(-1.9, 0.3, -0.2, 2.1) The steps() class of timing functionssteps() 函数表示法定义了一个step函数，以等距离的步骤分割输出值的域。这个阶梯函数的子类有时也被称为阶梯函数。 Syntax 1steps(number_of_steps, direction) where: number_of_steps 是一个严格的正数&lt;整数&gt;，表示构成步进函数的等距踏板的数量。 direction 是一个关键字，指示函数是左连续的还是右连续的：start表示一个左连续函数，所以动画开始的时候是第一步;end表示一个右连续函数，以便动画结束时发生最后一步。结束是默认的。 ExamplesThese timing functions are valid : 12345678910/* There is 5 treads, the last one happens right before the end of the animation. */steps(5, end)/* A two-step staircase, the first one happening at the start of the animation. */steps(2, start)/* The second parameter is optional. */steps(2) These timing function are invalid : 123456789/* The first parameter must be an &lt;integer&gt; and cannot be a real value, even if it is equal to one. */steps(2.0, end)/* The amount of steps must be non-negative. */steps(-3, start)/* There must be at least one step.*/steps(0, end)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>transition</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端路一步步走，重新再来]]></title>
    <url>%2F2017%2F10%2F23%2F%E5%89%8D%E7%AB%AF%E8%B7%AF%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%B5%B0%EF%BC%8C%E9%87%8D%E6%96%B0%E5%86%8D%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[目录就不写了，左边菜单有锚链接 为什么要写这篇文章是因为好几次可能遇到了问题的瓶颈了，虽然还是解决了，但是仍旧不懂其原理，大多也只是百度寻求出的答案，所以感觉自己可以学的更好但是仍有不足，对深层次的地方尚未了解的透。 其二，最近看到一张图，可能也是玩笑吧，不过还是体会到了自己的不足。这张图大致说的就是：“如今的程序员并不是想象中收入很低的群体，收入超过3W/Mon才能真正说为程序员，而那些3W以内的只是自称是程序员的码农而已。。。” 看着自己收获着仅有3k的工资，想想也是，作为一个实习生差不多了。不过再仔细想想，还是觉得自己掌握的也就那几部分，看看别人潜心研究的视频，拿别人的工具做做自己的项目，不敢拿一些star量少的框架，害怕找不到问题的答案，因为自己看不懂源代码，或者没有看源码的经验，害怕浪费太多时间。所有的所有都体现着自己能力不足，需要握紧基础的迫切。 其三，虽然现在已经在初创公司工作一个月了，我并不认为在一些教育工作，外包公司工作，实习会比现在更好，我更感觉那些公司更会像人力的压榨机，或者任由你不管不问，初创公司至少会有一点比他们好点，人少，关怀就多一些，项目不重而且会有时间来教导你。我觉得是今后如果有些毕业生可以选择的方向。而且又CTO带着你，4年的工作经验，几乎你会的，他都会，所以根本不用担心。 这个月需要完成的计划其实这一部分，我已经写在提醒事项里了，不过计划赶不上变化，日日如此。也顺便列出一些理由 好好学透 ES6 这个语法和知识点不管是 ES6 还是 ES5 甚至 ES7 过去 JS 所犯的错误和它如今或者今后要去做的任务都大致写在了里面，从5开始将浏览器的规范合为一体，到6想要将从后端语言中抢来一定的席位，到7开始大量关切语法糖和必要的修饰，这些都可以看出 JS 这门语言发展有多迅速，蔓延地有多深。最直接可以看出地就是 GitHub 上 JS 开源量年年领先于其它语言。所以学好这门语言的基础就是好好利用好新语法，新写法。 HTML 中尤其是 H5 中最新的 DOM API可能之前有很好的替代方案，比如 flash 做一些视频， flash 做摄像头的获取，JQ 中对 DOM 的操作等等。不过随着前端web浏览器几乎每月的更新，Chrome 更是每周的更新，好用的API不为我们所知，可以他们的确是可以用了，而且是原生的，不用加入JQ等一些第三方的插件了。所以好好并且细细地学一遍DOM API还是很有必要地。 CSS CSS3 动画，关键帧，变换的使用真的，如果要让你的见面时刻展示给用户最美的体验，视频插入之外，CSS动画毋庸置疑是必须要了解和掌握的。特别是利用一些第三方的引入，可能会让你更加了解动画的整个过程。 Canvas WebGL来开发3D或者2D在某些地方是效率是绝对比CSS3要高的，而且，在VR或者AR上，他们更具有优势。希望还是能学到这儿。 WebRTC 实时语音的功能，这里不太了解，暂且放这儿 WebSocket 浏览器与服务器端的双向通信 还有很多技术真的，很多😭 将来可能要接触的方向 React 的开发说真的，虽然Vue还是依然的火热，但是React的想法真的比Vue更加特别与奇特，所以等我攒了钱买了台好点的Mac Pro笔记本，我必将细细品味真正的前端。 Meteor 的开发与React 一样，几近全栈的开发的一门框架，最近才了解到，虽然录得那个视频是15年录得好似，不过这个框架人具有不少令人尝试的勇气。 其它就不多说了，还是走一步是一步，万一又出来一个比较叼的语言或框架呢？ 补充 TypeScriptTypeScript有着 JS 的优点，并补足了 JS 不严谨的缺点，可以适当学习😊]]></content>
      <categories>
        <category>日志</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 与远程仓库(Remote)的那些事(坑)]]></title>
    <url>%2F2017%2F10%2F13%2FGit-%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93-Remote-%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B-%E5%9D%91%2F</url>
    <content type="text"><![CDATA[参考：（无） 前言好久没有更新博客了，自上次9月25日更新了一些数据结构的笔记以后，去忙别的事情了，原因的话，应该都懂。工作啦，还是学习，买手机等等，总之还是在规划自己的学习路线，时刻更新下，毕竟计划赶不上变化。突然写这篇文章的原因有很多，有惠阳学弟向我要一些文章博客，还要我的博客…我就突然想起来了（我他妈博客几年没更新了，在我脑中），还有就是最近项目都有用到 Git 这个版本管理工具，虽然之前我经常用，不过自己平时与工作的情景毕竟已经不太一样了，除了要知道最基本的 git init , git add -A, git commit -m &quot;your commit&quot;, git push 等等，最重要的是你的远程管理仓库是不一定只有一个，比如我们公司要用的是 gitlab 这完全与 github 不是同一个远程库，你得学会怎么同时管理多个远程库，而且里边有许多坑（Hole），这些坑你得自己找，网上是找不到的，毕竟现在人工智能的范围未能达到如此地步（我会在下文介绍一些我遇到坑）。 目录 怎么将本地库与远程库关联 使用ssh-key去验证自己的身份 多远程仓库的管理与配置 一个巨大的坑（详细介绍） 怎么将本地库与远程库关联 其实 图1 已经给出明确的答案了，如果需要详细的网页可以点击这里这张图中第二部分就是给出的是，如果你已经先在本地有 Git 仓库了，当然注意，这个仓库一定是已经 git init 过的，或者说是 git clone 过的，不能你自己以为就是以为。然后，执行这句命令 1git remote add origin https://github.com:[yourusername]/[repo].git yourusername 是你在github或者其它刚刚建立的远程仓库的使用者，也就是你自己的昵称repo 是你建立的仓库名字，这步一定是最前的，不然你怎么跟本地库关联。 最后将本地库推送到远程库执行这句 1git push -u origin master 意思就是 推送 到 origin (没错这就是刚刚指代的你的远程库代称) master 就是远程库的 master 分支 使用ssh-key去验证自己的身份可能看完上一章的童鞋会问，ssh-key是干吗用的，不是只要知道 push , pull, clone 命令就可以了吗？看样子好像，似的。但是又不是你可以自己看看 图1 的截图，和刚才添加命令中的地址信息，你知道 https://github.com 是什么意思吗？我们放大 图1 的细节 有 https 和 ssh 选项，而且你点击哪个，他的地址就会发生改变ssh: git@github.com:Lanseria/e.githttps: https://github.com/Lanseria/e.git这两种加密方式都是对你代码在 tcp 的传输中，不会被他人截取，所以不要想为什么没有 http 等等问题啦我说说这两者的区别吧 https 就像你登陆网站是去输入账户和密码来验证你的身份合法而 ssh 则采用流行于 linux 的 ssh 登陆的加密方式去管理你的账户所以两者的便捷性不言而喻最大的体验就是https 每次重启计算机，你下次去 push , pull , clone 都需要你重新输入密码而 ssh 就像你和远程的仓库， 比如 github 已经互相确认了对方的信息，只要双方的加密过的 key 正确，我就相信你 所以，入门者可以用用 https 但是， 如果你用到工作中， ssh 必然会方便很多 如何配置放一个官方的地址https://help.github.com/articles/connecting-to-github-with-ssh/你们应该不会打我吧不会百度嘛，很轻松的事我来列举下期间会用到的命令 1234567ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;// 这里 -b 4096 可以不加，邮箱填写自己的注册时的帮你邮箱Enter a file in which to save the key (/c/Users/you/.ssh/id_rsa):[Press enter]// 这可能会弹出这个，意思是这个key会保存在这里，并命名为id_rsa 你可以修改他的名字，不过建议如果你不是多仓库的话还是不要改了Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again]// 这两个是加密的密码，听起来很绕，但直接回车，设置为空就可以了，两下回车，第二个是comfirm的意思 最后就生成了你用编辑器，打开当个目录（/c/Users/you/.ssh/）的中*.pub的文件，将里边的字符复制出来放到github中ssh管理中，添加即可 多远程仓库的管理与配置来了，这个的前序章节让我假装新手，百度一下就这篇文章了吧https://my.oschina.net/guanyue/blog/485918它说（/c/Users/you/.ssh/）下添加config配置文件 12345Host gitlab.xxx.com ##可以随意命名，链接时使用这个名字 HostName gitlab.xxx.com User git Port 22 IdentityFile ~/.ssh/id_rsa_second 没了 一个巨大的坑（详细介绍）123456#github HostName 和Host一定要一样，不能随便取，为什么？自己找Host github.com HostName github.com IdentityFile ~/.ssh/id_rsa_home PreferredAuthentications publickey User youreamil@qq.com]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>ssh</tag>
        <tag>hole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法笔记1--绪论]]></title>
    <url>%2F2017%2F09%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B01-%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[参考清华大学数据结构课程链接 预备知识 C++：类，继承，重载，重写，虚方法，模板 离散：集合，偏序列，良序，数学归纳法，级数，递归，递推 概率基础：随机分布，概率，伯努利实验，数学期望，期望率，线率 一、计算与算法1.计算机的本质就是计算，寻找对象的规律，并从中找到技巧。计算的目标是高效，低耗。计算=信息处理2.算法就是借助一定的工具，在一定的规则下，以明确而机械的形式来进行的计算。计算模型=计算机=信息处理工具3.算法的主要特性： 输入，输出 正确性：算法能够正确地解决问题 确定性：所有步骤均由基本的操作组成 可行性：基本操作均能够实现 有穷性：所有操作在时间的允许范围内课程中主要讲解了一种 Hailstone 的一个例子但是 Hailstone 目前还未确认是否有穷 所以程序不一定是一个算法 4.好的算法正确：符合语法，能够编译，链接能够正确处理简单的输入能够正确处理大规模的数据（一般性，退化的，任意的合法的输入）健壮：能够辨别不合法的输入并做适当的处理，而不至于非正常退出可读性好：要有结构化+准确的命名+注释……效率（⚠）：速度尽可能快，存储空间尽可能少 Algorithms + Data Structures = Programs (Algorithms + Data Structures) * Efficienty = Compution 二、计算模型性能测度 To measure is to know. If you can not measure it, you can not improve it –Lord kelvin 不同的 DSA 这里简称 (Data Structures Algorithms) 的性能有好坏优劣之分，所以我们需要度量。 1.引入理想，统一，分层次的尺度2.运用尺度，以测量 DSA 的性能 算法分析：1.正确性2.成本（运行的时间有+空间）如何度量，如何比较 一般的计算模型有图灵模型与RAM模型，它们均将算法的运算时间转换成算法执行的基本操作次数。 三. 图灵机模型1.图灵机的三个组成要件有限长的字母表： cell中存储的内容读写头：指示当前位置，可读可写。状态表：当前读写头的状态 2.图灵机状态转换过程 transform(q,c;f,L/R,p)q：当前状态c：读写头所指cell当前的内容f：读写头所指cell改写的内容L/R：向左/右移位p：读写头转换后的状态 四. RAM 模型1.与图灵机类似，均假设有无限空间2.由一系列顺序编号寄存器组成，但总数无限3.算法所运行的时间转换成算法运算时的次数 五、大O记号 Mathematics is more in need of good notations than of new theorems. – Alan Turing 考虑长远，主流方向 渐近分析：大O记号Asymptotic analysis:当 n &gt;&gt; 2 后，对于规模为 n 的输入，算法1.需要执行的基本操作次数：T(n)2.需要占用的存储单元数：S(n) 1.大O记号(big-O notation)T(n) = O(f(n))f(n)为一个函数。当c &gt; 0, T(n) &lt; c ∗ f(n)，即大O记号表示T(n)的一个上界，其性质为：O(n)=O(c∗n)O(n2+n)=O(n2) 2.大Ω的定义：T(n)=Ω(f(n)) ,f(n)为一个函数。当c&gt;0,T(n)&gt;c∗f(n)，即大O记号表示T(n)的一个下界。 3.大Θ的定义：T(n)=Θ(f(n)) ,f(n)为一个函数。当c1&gt;c2&gt;0，c1∗f(n)&gt;T(n)&gt;c2∗f(n)，即大O记号表示T(n)的一个区间。 六、大O记号下的刻度1.常数复杂度(constant function)O(1)2 = 2017 = 2017 * 2017 = 2017^2017 //含RAM各基本操作这类算法的效率最高不含转向（循环，调用，递归）必须顺序执行2.对数类：O(logcn)与常底数、常数次幂无关，复杂度接近常数，有效。 3.多项式：O(nc)4.线性：O(n) 5.指数：cn=O(2n)任何c均可。成本增长极快，不是有效的。 七、算法分析两个主要任务 = 正确性（不变性 * 单调性) + 复杂度 复杂度的分析主要方法 迭代：级数求和递归：递归跟踪 + 递推方程猜测 + 验证 1.级数 Concrete Mathematics 2.循环与级数]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>面试</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript类数组转化为数组]]></title>
    <url>%2F2017%2F08%2F11%2Fjavascript%E7%B1%BB%E6%95%B0%E7%BB%84%E4%B8%8E%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[刚认识到这个知识点应该不晚吧~ 想想面试应该也会考到这类题，所以拿出来说说。不过前天的面试估计没过，还是挺惋惜的，主要还是我态度不怎样，一是觉得是培训公司（这么大的一个招牌挂在上面，心里看上去就挺不爽的）无所谓了。二来还是觉得太急，想晚点找个好点的工作，这次也就当 test 吧。不过面试中，我以为她都懂（就是一个正式的懂前端的人），现在想想，她就是拿着答案对我的口题，对我的笔试题，我想想就气。不知道技术的人拿着那种答案有什么用，只会一个劲儿的点点头，CTMD！（早知道，我一个劲的吹逼就行了，浪费我大一堆口舌 🙄） 切入正题，什么是类数组，它在我们频繁的操作中有什么关系，为什么要用到数组？ 其实，一切都要从对象还是讲起，毕竟JavaScript中任何类型都是基于一个对象有一篇国外文章可能对对象，数组，讲得更好，本篇文章会部分引用他的案例advanced-javascript-objects-arrays-and-array-like-objects 什么是类数组 我这里说的类数组是广义上的类数组，其解释就类似于能通过[].prototype.slice.call(ARRAYLIKE)转化为数组的形式。到目前为止，我用这类类数组转化为数组的方式，用在了许多地方 Buffer 对象，这是有点让我不解的地方 DOM 获取的同 className 的 DOM 节点群的类数组，当然还有同 tagName 最后一种就是大家都知道的典型例子， arguments所以呢，除了第一个，经常用js写前端的你，应该会碰到下面两种的转化 什么是数组什么是数组，也就是为了讲明什么要将类数组转化为数组的原因数组有很多好处，但这些好处都一并归纳在了这个数组对象所定义的方法里比如说，堆栈队列的操作，pop(),push(),shift(),排序的操作，sort()还有很多方法可以使用，这里也就不在一一列举数组与类数组有两点相似 都内部都自己的子元素 都有定义的长度 但是长度这里也比较奇怪的是 1234567var arr = [];arr[0] = "cat"; // this adds to the arrayarr[1] = "mouse"; // this adds to the arrayarr.length; // returns 2arr["favoriteFood"] = "pizza"; // this DOES NOT add to the array. Setting a string parameter adds to the underlying objectarr.length; // returns 2, not 3 The length property is only modified when you add an item to the array, not the underlying object.长度这个属性，只会在你添加或删除一个元素的时候与触发，当你自己定义它（这个数组）的属性时，它是不会增加的（就如同又来了一个length2属性）。 而且，当你直接定义一个比较远的数组索引时，比如100，这时，length总会比其索引值大1，而且不会报错，然后，中间的其它值会暂时的定义为undefined，以便填充 坑 Gotchas 其实这篇文章已经讲完了，不过还是要总结下，这期间遇到的坑 Gotchas DOM获取的class节点还是tagname节点都是一群对象组成一个类数组 最好使用一些库函数，such as lodash.js 将这些类数组进行转化]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>前端</tag>
        <tag>call</tag>
        <tag>数组</tag>
        <tag>类数组</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习jQuery源代码之三>>对象]]></title>
    <url>%2F2017%2F07%2F28%2F%E5%AD%A6%E4%B9%A0jQuery%E6%BA%90%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%89-%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[此系列文章大致参考 http://www.imooc.com/learn/172 类与函数面向对象(OOP)的语言都有一个特点，它们都会有类的这一概念，通过类可以抽象出创建具体相同方法与属性的对象。但是ECMAScript中是没有类的概念的，因此它的对象与基于类的语言如java的定义是有所不同的。 在 JavaScript 世界中函数作为“一等公民”，它不仅拥有一切传统函数的使用方式（声明和调用），而且可以做到像简单值一样赋值、传参、返回，这样的函数也称之为第一级函数。不仅如此，而且还可以通过操作符 new 来充当类的构造器。 函数在充当类的构造器时，原型prototype是一个重要的概念。prototype是构造函数的一个属性, 该属性指向一个对象。而这个对象将作为该构造函数所创建的所有实例的基引用(base reference), 可以把对象的基引用想像成一个自动创建的隐藏属性。 当访问对象的一个属性时, 首先查找对象本身, 找到则返回；若不, 则查找基引用指向的对象的属性(如果还找不到实际上还会沿着原型链向上查找, 直至到根)。 只要没有被覆盖的话, 对象原型的属性就能在所有的实例中找到。 其实这也就是JavaScript的剖析了，与其它语言不一样的地方就是类的构造不同，JavaScript没有类，即时是在es6中定义了class这个新特性，但它原则上还是认为function是第一公民，一切类的继承在JavaScript中都可以看作是一条条函数的原型链，通过scope将对应的属性找到。 jQuery的对象构造也是如此，虽然有两种写法 12345678910111213141516//类一：function ajQuery()&#123; this.name = 'jQuery'; this.sayName = function()&#123; return this.name; &#125;&#125;var a = new ajQuery();// chrome查看ajQueryfunction ajQuery()&#123; this.name = 'jQuery'; this.sayName = function()&#123; return this.name; &#125;&#125; 1234567891011121314// 类二function bjQuery()&#123; this.name = 'jQuery';&#125;bjQuery.prototype = &#123; sayName: function()&#123; return this.name; &#125;&#125;var c = new bjQuery()bjQueryfunction bjQuery()&#123; this.name = 'jQuery';&#125; 但是很明显第一种的写法在性能上更有优势，因为函数都是一样的，为什么要重复去申明呢？jQuery的大致写法： 1234567891011121314151617// jQuery的写法var $jQuery = function(selector, context) &#123; return new $jQuery.fn.init(selector, context);&#125;$jQuery.fn = $jQuery.prototype = &#123; init: function() &#123; this.name = 'aaron' return this; &#125;, constructor: $jQuery&#125;var $a = $jQuery();show('$jQuery的调用')show($a); 虽然ajQuery使用了类二的原型结构，性能上有优化，但与实际中的jQuery还是有很多不一样的。☑ 没有采用new操作符☑ return返回的是一个通过new出来的的对象 提示: 如果实在听不懂，可以看看大神写的一个比较有趣的jQuery讲解，张大神-jQuery诞生记-原理与机制 里面也有许多点可以提一提，是个不错的方案，以后可以用在一些模块的写法上。比如在重复获取 ID 上，可以偷点懒 12345678910111213141516171819202122232425262728293031var $ = function(selector, context)&#123; return new $.fn(selector, context);&#125;;$.fn = function(selector, context)&#123; return this.init(selector, context);&#125;;$.fn.prototype.init = function(selector, context)&#123; var nodeList = (context || document).querySelectorAll(selector); this.length = nodeList.length; for(var i = 0;i&lt;this.length;i++)&#123; this[i] = nodeList[i]; &#125; return this;&#125;$.fn.prototype.each = function(fn)&#123; var i = 0, length = this.length; for(; i &lt; length; i++)&#123; fn.call(this[i], i, this[i]); &#125; return this;&#125;;$.fn.prototype.hide = function()&#123; this.each(function()&#123; this.style.display = "none"; &#125;)&#125;function ()&#123; this.each(function()&#123; this.style.display = "none"; &#125;)&#125; 对象`]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>前端</tag>
        <tag>jquery</tag>
        <tag>prototype</tag>
        <tag>object</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法，Javascript也有算法(2)]]></title>
    <url>%2F2017%2F07%2F25%2F%E7%AE%97%E6%B3%95%EF%BC%8CJavascript%E4%B9%9F%E6%9C%89%E7%AE%97%E6%B3%95-2%2F</url>
    <content type="text"><![CDATA[提示 这系列文章我会时常更新，时间也会相对应的更新，如果对前文想略过，可以直接点击这里今天来讲什么的？我只能说小算法 今天算是比较熟悉面试（牛客网）中的算法流程，虽然 node v0.12 版本的很恶心，但还是可以用的 一、数据结构参考：http://www.thatjsdude.com/interview/linkedList.html 链表链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。 单链表（单向链表）链表中最简单的一种是单向链表，它包含两个域，一个信息域和一个指针域。这个链接指向列表中的下一个节点，而最后一个节点则指向一个空值。 任何语言都有千万种表示方式去呈现链表，这里我写出两种，一种是在参考上的，一种是参考leetcode上的链表One: 1234567891011121314151617181920212223242526272829function LinkedList()&#123; this.head = null;&#125;LinkedList.prototype.push = function(val)&#123; var node = &#123; value: val, next: null &#125; if(!this.head)&#123; this.head = node; &#125; else&#123; current = this.head; while(current.next)&#123; current = current.next; &#125; current.next = node; &#125;&#125;var sll = new LinkedList();sll.push(2);sll.push(3);sll.push(4);console.log(sll);console.log(sll.head);console.log(sll.head.next);console.log(sll.head.next.next); Two: 123456789101112function ListNode(val) &#123; this.val = val; this.next = null;&#125;ListNode.prototype.push = function(val)&#123; var node = new ListNode(val); var current = this; while(current.next)&#123; current = current.next &#125; current.next = node;&#125; 双链表一种更复杂的链表是“双向链表”或“双面链表”。每个节点有两个连接：一个指向前一个节点，（当此“连接”为第一个“连接”时，指向空值或者空列表）；而另一个指向下一个节点，（当此“连接”为最后一个“连接”时，指向空值或者空列表） 12345678910111213141516171819202122232425262728293031class DoublyLinkedList &#123; constructor() &#123; this.head = null; &#125; push(val) &#123; var head = this.head; var current = head; var previous = head; if (!head) &#123; this.head = &#123; value: val, previous: null, next: null &#125;; &#125; else &#123; while (current &amp;&amp; current.next) &#123; previous = current; current = current.next; &#125; current.next = &#123; value: val, previous: current, next: null &#125;; &#125; &#125;&#125;var dll = new DoublyLinkedList();dll.push(2);dll.push(5);console.log(dll.head.next.previous); 二、算法1.回文数的最小个数这里我只能大致讲一下题目意思，百度也有，也是只有 JavaScript 做的，所以我这里把题目抄一下： Description提供一个字符串 s ，其中每个字符都是小写字母。并提供字符串长度。要求：输字符串 s 中元素拼凑出的回文串的最小个数。其中，每个字符只能使用一次。例如： s=&quot;abbaa&quot; ，输出 1 ，因为最少可以拼凑出 &quot;ababa&quot; 这一个回文串。 s=&quot;abc&quot; ，输出 3 ，因为最少只能拼凑出 &quot;a&quot;，&quot;b&quot;，&quot;c&quot; 这三个回文串。 其实说实话，毫无思路，因为你不可能枚举那没多种情况，在网上看到题解之后，也懂了（秒懂）。因为在一个随机的字符串中，如果需要求最少的回文个数的话，只要找其中每个字母的个数就可以了，其中呢，偶数完全不需要考虑，但是奇数个是整个回文数的核心，同个字母有几个个数就有几个回文数。偶数的字母只要靠边站就行了。有思路就有动力了，用一个Map就可以了，再用一个数组将Map中的值包括起来，对奇数个数进行计算，就可以得出最后的结果了。 1234567891011121314'use strict';function count(str) &#123; str = String(str); if (!str) &#123; return 0; &#125; var nums = str.split('').reduce(function (map, s) &#123; return map.set(s, (map.get(s) || 0) + 1); &#125;, new Map()); return Array.from(nums.values()).reduce(function (odd, n) &#123; return n % 2 !== 0 ? odd + 1 : odd; &#125;, 0) || 1;&#125;]]></content>
      <categories>
        <category>技术</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>算法</tag>
        <tag>回文数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法，Javascript也有算法(1)]]></title>
    <url>%2F2017%2F07%2F23%2F%E7%AE%97%E6%B3%95%EF%BC%8CJavascript%E4%B9%9F%E6%9C%89%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[提示 这系列文章我会时常更新，时间也会相对应的更新，如果对前文想略过，可以直接点击这里今天来讲什么的？我只能说小算法 前言现在还没工作的我，对IT互联网的技术也有自己的一番认知，同时尽量把我所知道的传播给下面的学弟学妹，让她们提提力气，不要只局限于老师所教的知识就以为，以为计算机这个大专业就这么点东西。虽然身在电科这个很·棒的专业，但我也在日常与室友计科软工的带领下，自己走向一条对自己适合的道路。什么都会点，还是不太精，什么都做过点项目，但是成品还是有点粗糙。我的理念也不像那些呆在实验室的人一样，老师给什么，就做什么。老师提什么，我都会跟他一块去讨论，将别人的想法稍稍改变下，总的来说，使项目朝着自己所期望的做，所以一般情况下，项目转交给别人，一般就传不下去了…… 废话又扯多了，算法，咳咳说实话，大一参加ACM我竟然退了，现在开始想想也挺后悔的，更后悔的是还在一个现在根本不想呆的地方，浪费了我这么多时间。说到ACM，难免会提到算法，可能大一的我没能认识到算法的重要性，觉得它并有没实际的优越感，就放弃了，想想很可惜的。好的程序 = 优秀的算法 + 可靠的数据结构万年不变的真理啊，但真正能掌握他们的人，少之又少。 Javascript需要算法吗？甚至更加简单一点的，前端需要算法吗？可能很多人都会说，不就是写界面吗？还需要这么高深的算法吗？对，你们所知道的前端还是过去的前端，属于设计师与代码混合的年代，而现在分工却更加的明确。前端需要更多的知识填充，而这些知识包括，websocket，tcp，http，网络，linux这些后端才会遇到的知识。所以，想当然，算法是完全有必要的。 今天来讲什么的？我只能说小算法个人比较谦虚，真是不会太难的算法，所以这里只能将我了解到的算法，在这里给你们分享下，当然，介绍算法的同时不会忘记介绍JavaScript中的数据结构。 推荐的OJ： LeetCode 阅读推荐： 算法导论 算法设计与分析基础 程序员代码面试指南：IT名企算法与数据结构题目最优解 一、数据结构参考：http://www.thatjsdude.com/interview/linkedList.html 1.堆栈和队列如果不是 JavaScript 的新手，应该知道JavaScript是已经自己实现了堆栈和队列。你只需要简单的调用 push ， pop ， shift 这些操作 array 的函数即可。不过，你甚至对C++中的优先队列有点印象的话，也有人实现了类似的原型构造，priorityQueueJS的简化版本堆栈： 1234567891011var myStack = [];//pushmyStack.push(1);myStack.push(2);myStack.push(3);//popmyStack.pop(); //3myStack.pop(); //2myStack.pop(); //1 队列： 1234567891011var myQueue = [];//pushmyQueue.push(1);myQueue.push(2);myQueue.push(3);//popmyQueue.shift(); //1myQueue.shift(); //2myQueue.shift(); //3 Priority Queue优先队列 12345678910const PriorityQueue = require('./priorityqueue')var p = new PriorityQueue();p.enq(1);p.enq(3);p.enq(2);console.log(p.deq())console.log(p.deq())console.log(p.deq())console.log(p); 二、算法算法不像数据结构，每个人都有每个人的想法，思维的不一样，导致写出来的代码精炼程度也不大一样，所以，我这里在我自己与室友的帮助下，会写下自己在 LeetCode中的题解，与之对应的算法。 1.尺取法 去一块一块地去截取你所要的序列，一旦不满足就后自增1，前再去探索，使其满足要求，也如同蚯蚓的爬动，用O(n)的复杂度，求得最优值。 尺取法我想我这种程度是想不到类似巧妙的算法的，我之前的算法自己想想就觉得太复杂了。而且呢。没有AC掉题，代码真是又臭又长。之后寻求了室友的帮助提示，他告诉了我尺取法来解决这类序列不动求其最长或最短的方法，一下子就把问题变得简单了。所以以后遇到类似的问题，不用在意是数字还是字母，只要要求序列不排序，就可以用此方法解决。 举个 LeetCode 中较为形象的题型 1.例题：求最长子字符串Longest Substring Without Repeating Characters DescriptionGiven a string, find the length of the longest substring without repeating characters.Examples:Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3.Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1.Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 这里它还提醒我们跟之前的题不太一样，这个序列不准变，不是求最长子序列，是最长子字符串来说说我之前的复杂的想法吧，首先将字符串转化成数组，然后慢慢去用 new Map() 这类数据类型去找不一样的字符串，如果不对记录下其长度，放入数组中，最后求出最大值，！但是这个解决方案看似完美，但有致命的缺点，就是忽略了第一次确定了那个最长序列之中的有可能的最长序列。所以让我们还是用最优的方案吧–尺取法 1234567891011121314151617181920/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s)&#123; var m = new Map(); var Imax = 0; var i = 0, j = 0; while(1)&#123; while(j&lt;s.length &amp;&amp; !m.has(s.charAt(j)))&#123; m.set(s.charAt(j)); j++; &#125; Imax = Math.max(Imax, j-i); if(j &gt;= s.length) break; m.delete(s.charAt(i++)); &#125; return Imax;&#125;; 说明这个整体思路就相当清晰了，除了避免了字符串变数组的多余的循环，也添加了尺取法的构思，可看到，while这个语句在算法中是经常能用到的。首先利用es6的新特性，map数据结构，使这个数据有数据有字典的属性，可以方便的查询。然后定义头与尾，用头去探索，尾部去迭代，只要头部探索完毕，就释放尾部进1。使头部继续去探索。最后求得最大值。]]></content>
      <categories>
        <category>技术</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>尺取法</tag>
        <tag>堆栈</tag>
        <tag>队列</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重新整理下自己，轻装上阵]]></title>
    <url>%2F2017%2F07%2F08%2F%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%8B%E8%87%AA%E5%B7%B1%EF%BC%8C%E8%BD%BB%E8%A3%85%E4%B8%8A%E9%98%B5%2F</url>
    <content type="text"><![CDATA[前言大学三年，从学习图片处理开始，再到视频制作，最后转到真正的去敲代码，这个过程现在看来还是挺令人不可思议的。不过，现在经历过面试，笔试，虽然在社团中还是十分自信的，但在社会中，面对社会上的人还是跟你在学校里遇到的情况是十分不一样的。不得不说，社会很险恶，你不懂交际，不懂一些交情，更直白的说吧。除了直接推荐这样的方式，一切都是公平的。 所以，你不能靠很多你自己，就比如说我，自己在大学里的想法做的项目来让人家刮目相看，并且你能面试的工作职务少之又少，其它的要求很高，你并没有考得相应的证，或者真正的实习经验，人家根本不会去看你。 所以，总之，好的公司需要的人才分很多种，比如在前端，公司需要的是人才有两种，一种专门设计，这种不管，还有一类就是动画，通过JavaScript设计类似3D的动画，像这类工作，工资一定是比第一类的高得多，但是这类人才，在现在的情境下，必须有一直创新地去学习地想法，其中一个最大的原因就是JavaScript这门语言太酷炫了，使得前端这朵花开的一塌糊涂，现在已经可以去抢占后端的饭碗了。 其它比如java，比如C#，两大除了C/C++以外的通用全能语言渐渐变得不是那么引人注意了，我同样也是这么认为，首先IDE太大，对于入门者完全不懂它加载地这么慢，到底与我有什么关系。所以，以我地认知来看，那种专一性，简洁性的语言，会慢慢蚕食这类通用型语言。 可以很形象的举个例子，现在除了对于性能不高的场景下，解释性语言已经很流行了，比如python，JavaScript，等等其它语言，它们不必编译，但是功能很强大，操作上手很快，特别是在某些领域中，它们简直是那里的老大，用它的人都喜欢它的语法，它们代码风格，更直接点，喜欢它的规范（因为规范就是从人群中来的） 描述问题 到底怎么整理自己的博客？ GitHub中的项目如何正确维护？不泄露一些重要密码？ 书签的整理问题，到底如何整理技术书签？ 优秀博客中的知识点如何整理？ 实战视频中的要点如何记录？ 自己探索中的经验，想法，或者突然的项目该如何记录？ 团队思想探索到底怎么整理自己的博客？其实探索过许多写博客的方法，wordpress，自己搭建博客，github静态挂载（hexo）其实与有些大佬一样，不同的人有不同的困惑，在我看来，wordpress是一个原生PHP搭建的著名的博客框架，虽然很好用，但是！问题还是有很多的，比如，头像不能正常显示，因为墙的缘故，当你注册过之后，几天之内，你可能就会发现有不明的账户会在你的博客上注册，还有就是图片容量问题，不过可以用七牛云免费的1G空间帮你解决这个尴尬的问题。结果当然是不太理想。自己搭建博客，虽然费时费力，但可以很好的找出问题所在，不用费力的去看看源代码或者着急的问大佬的问题，但缺点也是有的，性能可能不太好，功能会有一些单一，最主要的还是安全性得不到保证。hexo等一些静态博客，都不错，就是图片整理困难，在文档中插入图片不是那么的方便。最喜欢的特点就是主题真的十分多。GitHub中的项目如何正确维护？不泄露一些重要密码？在我现在的项目中，可能你还是可以发现，在项目特别是PHP的项目中，其配置文件仍存有一些我遗忘删除的php代码，里保存着我的一些数据库的密码资料。这也难免，在windows下完成的项目，移交到服务器端总是不怎么方便，所以当时很童真的我以github为中间渠道，push&amp;pull上传下载，以用来本地与服务器之间的同步。可是现在来看，这种方式肯定有不可取的地方。书签的整理问题，到底如何整理技术书签？书签的整理问题，我认为是一个比较好解决的问题。之前的过程中，我凡是遇到好的网页，好的博客，更甚至说好的文章，我总会点击chrome地址栏右侧的收藏icon，以方便今后阅读，不过现在看来这是一个近似于无效的方案，收藏的当时只是出于兴趣，你未必能够在将来去回顾你这些所谓的好文。优秀博客中的知识点如何整理？一篇冗长的好文章，虽然是一篇好文，但你需要的点只有那几点，而且是希望以后融入到你的程序，或者总结文章上去的。如果你只是翻翻而过，或者对一些敲敲而过，很快你会失去这么有用的代码。所以，即时性的收藏方式一个很好的解决方案，你可以将一并收纳，并在有需要的时候，互相贯通。既可以学习又能复习的方法，岂不最佳？实战视频中的要点如何记录？这个问题与上一个问题类似，唯一不同的就是视频一种说好但不是很方便的一种教学方式。没错，视频是一种十分稀缺的资源，他能让一些入门，或者缺乏独自学习官网或者源码的孩子开启了新的一扇门。不过缺点也是依稀可见的： 1.下载它容量大，使得你不能很好的携带。2.复习，回顾的时候，你很难从中寻找，这与文档相比就让很明显了。3.老师的教学方式都十分不一样，所以你需要适合多样化的教学方式。 自己探索中的经验，想法，或者突然的项目该如何记录？这种探索，我可以说，你们也能经常碰到，我举一个很简单的例子，比如，在学习微信公众平台的时候，你可能希望能够搭建一个属于自己的平台，并十分希望大家一起来看你的优秀管理，也难免说起来很容易，但做起来是很困难的，你在很好的管理的同时，你需要对你的文章有很好的筛选，如果你有很好的算法，你简直可以在企业中获得很好的职位，因为这些智能的算法，是能够很好的解决工作繁琐，错误过多的问题。想法该如何记录？？Emmm就写在书上吧。 团队思想探索团队在组建与管理，是我现在十分想做的一件事，不过并不是每日签到签退这类活，我只想对成员有更好的教育意义，对这个团队的发展有更好的启蒙想法。当然这些想法希望不是全部出自于我，我也热于和我志同道合的人，或者有些激进想法的人能有思想上的冲击，能说服我，更新迭代我的世界观，说真的，我希望能够天天更新我对世界的认知，对知识不断索取，是我热爱的。 实际解决方案 到底怎么整理自己的博客？我的解答 GitHub中的项目如何正确维护？不泄露一些重要密码？我的解答 书签的整理问题，到底如何整理技术书签？我的解答 优秀博客中的知识点如何整理？我的解答 实战视频中的要点如何记录？我的解答 自己探索中的经验，想法，或者突然的项目该如何记录？我的解答 团队思想探索。我的解答到底怎么整理自己的博客？我的解答博客这个是个可以讨论的一个小问题，很多很多小白，包括之前的我，都有一个天真的想法：作为一个程序猿，自己的技术笔记越多，就感觉自己越厉害。不过，现在来看，博客这个可不是小白的垃圾场，我们不希望有一些不易懂，或者写的很糟糕的文章呈现在百度搜索页的前列，google的前边，希望某个问题的解决，能有一些很规范的博文能够给迷失者指引方向。我们要确立一个很明确的一个核心–“博客是用来干什么的？”-&gt;&gt;“分享经验或者人们所需要的点。” 1.不要单一的造轮子，做轮子（具有一定的技术性的文摘）。2.自己平日里的日志，日记，想法，或者感受（个人日记是个不错的归档）。3.面试（给自己，也给学弟学妹一点自己小小的经验）。4.靠自己技术，抓取或者分析的大量数据的展示（数据测试分析）。 GitHub中的项目如何正确维护？不泄露一些重要密码？我的解答通过百度还是stackoverflow还是挺辛苦的找到一种方法去解决如何将已经add的文件，在接下来的修改中，不会引起git的关注，同样的方便了local（本地），Server（服务器），Github（远程托管）的过程中不会很麻烦的去修改配置文件，同样也避免了懒得去修改配置文件带来的数据库密码泄露的问题。方法是：不想继续跟踪的文件git update-index --assume-unchanged &lt;file&gt;反之使其正常跟踪git update-index --no-assume-unchanged &lt;file&gt;如果有其它解决方案，你也可以私聊我。 书签的整理问题，到底如何整理技术书签？我的解答 优秀博客中的知识点如何整理？我的解答 实战视频中的要点如何记录？我的解答 自己探索中的经验，想法，或者突然的项目该如何记录？我的解答我觉得这三点可以一起说明假装有一个图可以描述我的情景所以不仅在浏览器中要有Search书签文件夹，Temp书签文件夹，Future文件夹，在需要在OneNote中新建书签与Future书签，Future书签将逐渐归纳到书签中，也就是OneNote了。换句话来说，你在OneNote只要创建一个用来管理临时的书签就可以了。团队思想探索。我的解答引用百年老店IBM总裁彭明盛的一句话–“唯一需要保持的新年，就是要不断做出改变”。当今互联网时代，商业环境复杂多变…接下来的话可能跟我们程序员一点关系都没有，可是遭遇的问题是一样，一致的，就是语言这类技术，发展的越来越快，随着越来越多的人的加入，新语言一定是不断产生并与就语言产生火花的。一个IT从业人员需要在信息上不断获取，在头脑上不断更新，有着创新的理念，万事学会去接纳，才能被称为不落伍的人。此段未完待续~ 参考论文与知乎1.IT部门只能演变机器重新定义2.IT项目管理者的个人发展方向如何定位？]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>ME</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习jQuery源代码之二>>构建对象与加载]]></title>
    <url>%2F2017%2F07%2F01%2F%E5%AD%A6%E4%B9%A0jQuery%E6%BA%90%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%BA%8C-%E6%9E%84%E5%BB%BA%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[此系列文章只是为我（当然如果你能看懂的话也是为你们）稍微深入JavaScript的难点，毕竟作为前端工程师并不是那么简单的。这篇文章的前一章 jQuery的构建对象jQuery 神奇之处有很多，其中一个就是jQuery对DOM对象的包装。我们都知道jQuery的入口开头就是一个$符.函数原型$([arguments...]) 通过传递参数的不同，实现了9种方法的重载： 1234567891. jQuery([selector,[context]])2. jQuery(element)3. jQuery(elementArray)4. jQuery(object)5. jQuery(jQuery object)6. jQuery(html,[ownerDocument])7. jQuery(html,[attributes])8. jQuery()9. jQuery(callback) 分别有选择器，DOM处理，DOM加载的操作为什么jQuery也有数组一样的操作呢？起因是JavaScript独有的原型的概念，然后jQuery自带类数组的存储结构，一旦这两者通过prototype链接起来，那我们就可以将DOM对象，既可以用对象一样操作，也可以像数组一样操作。接下来我们通过一个简单的示例来模拟下jQuery的对象大致构建 在代码中有一句可能很疑惑， 123if (!(this instanceof aquery))&#123; return new aquery(selector);&#125; 其中instanceof用于当前环境是否在局部环境中，使this也就是上下文处于这个对象之中，而不是去引用window这个全局变量return new aquery(selector);这个不仅是去创建一个对象变量，更是去创建一个对象环境这样才有了以下调用this不会出错的现象这里不要搞错之前用JavaScript去创建一个类，也就是contructor object构造对象之前用的不是匿名函数，而这里是将一个匿名函数赋值给一个变量 1234function Person(name)&#123; this.name = name; this.sayHello = function()&#123;alert(&quot;hello, I am &quot;+this.name);&#125;&#125; 我这里也拿出另一种创建对象的方法，虽然这是一个简陋的写法 123var person1 = new Object();person1.name = &quot;mike&quot;;person1.sayHello = function()&#123;alert(&quot;hello&quot;);&#125;; 注意这里就不能用this了，当然也有其它方法，我这里就不再演示，主要是为了比较上面的new aquery()这个对象有什么区别。jQuery的加载首先还是要讲讲面试要考的地方 比如DOM文档加载的步骤：(1) 解析HTML结构。(2) 加载外部脚本和样式表文件。(3) 解析并执行脚本代码。(4) 构造HTML DOM模型。//ready(5) 加载图片等外部文件。(6) 页面加载完毕。//load 可以很明显看出ready的方法在DOM模型结构处理完就可以运行，然后就是开始加载图片资源，直到页面全部加载完毕才可以执行load里面的代码。所以我们该如何分配代码的运行呢？虽然这个问题我也没有仔细考虑过，不过大致情况还是有分很多种的：比如要用js构造DOM结构的一定要放在ready时，不过为了页面加载速度快，如果你的代码运行时间长，要么精简代码的时长，也就是使用更优秀的算法，要么删减要加载 DOM 的数量我们来看看jQuery是如何处理文档加载时机问题的： 12345678910111213jQuery.ready.promise = function( obj ) &#123; if ( !readyList ) &#123; readyList = jQuery.Deferred(); if ( document.readyState === &quot;complete&quot; ) &#123; // Handle it asynchronously to allow scripts the opportunity to delay ready setTimeout( jQuery.ready ); &#125; else &#123; document.addEventListener( &quot;DOMContentLoaded&quot;, completed, false ); window.addEventListener( &quot;load&quot;, completed, false ); &#125; &#125; return readyList.promise( obj );&#125;; Query的ready是通过promise给包装过的，这也是jQuery擅长的手法，统一了回调体系，以后我们会重点谈到。addEventListener这个方法虽然在用在了document上，但是它继承了node这个父元素，node这个父元素又继承了EventTarget这个最大的元素可见jQuery兼容的具体策略：针对高级的浏览器，我们当前很乐意用DOMContentLoadedEventLister事件了，省时省力。如果是旧的浏览器，它是通过判断IE的doScroll是否加载完毕在判断的这都是我们在第一时间内处理ready加载的问题，如果ready在页面加载完毕后呢？ jQuery就必须针对这样的情况跳过绑定了： 1234if ( document.readyState === &quot;complete&quot; ) &#123; // Handle it asynchronously to allow scripts the opportunity to delay ready setTimeout( jQuery.ready ); &#125; 直接通过查看readyState的状态来确定页面的加载是否完成了。这里会给一个定时器的最小时间后去执行，主要保证执行的正确。 jQuery多库共存处理多库共存是为了避免全局变量$一直被jQuery一直占用，jQuery的内置noConflict()的函数可以将$变量转让出去，避免其它库用不了$的问题发生 当然其中的原因也很简单，就是利用变量环境交换 123456789101112var _jQuery = window.jQuery, _$ = window.$;jQuery.noConflict = function( deep ) &#123; if ( window.$ === jQuery ) &#123; window.$ = _$; &#125;if ( deep &amp;&amp; window.jQuery === jQuery ) &#123; window.jQuery = _jQuery; &#125; return jQuery;&#125;; 通过类似swap交换的概念，先把之前的存在的命名空间给缓存起来，通过对比当前的命名空间达到交换的目的，首先，我们先判断下当前的的$空间是不是被jQuery接管了，如果是则让出控制权给之前的_$引用的库，如果传入deep为true的话等于是把jQuery的控制权也让出去了]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>前端</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习jQuery源代码之一>>模块与对象的构造]]></title>
    <url>%2F2017%2F06%2F21%2F%E5%AD%A6%E4%B9%A0jQuery%E6%BA%90%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%80-%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%2F</url>
    <content type="text"><![CDATA[此系列文章只是为我（当然如果你能看懂的话也是为你们）稍微深入JavaScript的难点，毕竟作为前端工程师并不是那么简单的。 一边看老师的视频，一边敲代码，只知道效果，却不能完全理解其它的意思，偶尔会有看不懂的地方，还得自己百度一会儿，不过一会儿就忘了。这是一种急于求成的方法，做多了也无大用处，项目做多了，也应该回头望望，从零开始，能去读懂别人的代码（当然是比如著名框架的代码），学着别人的方式去写一些比较有意义的小插件还是不错的。 多做少说，我就赶紧开始吧。 这里我阅读的是jQuery2.1的源码，应该不会有多大差别。 首先，记住下会考的面试题：jQuery是继prototype之后又一个优秀的Javascript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。 The Write Less,Do More（写更少，做更多），无疑就是jQuery的核心理念，简洁的API、优雅的链式、强大的查询与便捷的操作。从而把jQuery打造成前端世界的一把利剑，所向披靡！ 慕课网 重点1：简洁的API（不仅简洁而且时常能用到）、优雅的链式、通过正则写的强大的选择器… 重点2：2.1之后也就现在我用的版本就不支持旧的浏览器了，我这里就不得不吐槽一句，兼容这事我不想搞啊！！！（让别人去搞好了，我学好新技术，（偷笑~）） 重点3：这也是特色，就是好多插件都必须在jQuery的前提下才能使用，这谁开发过网站的都知道，用个图表，用个轮播图，等等，不先引用个jQuery你就别想有优美的效果！ jQuery的整体架构虽然不太懂，但也根据慕课网是的提一提 五大块：jQuery按我的理解分为五大块，选择器、DOM操作、事件、AJAX与动画，那么为什么有13个模块？因为jQuery的设计中最喜欢的做的一件事，就是抽出共同的特性使之“模块化”，当然也是更贴近S.O.L.I.D五大原则的“单一职责SRP”了，遵守单一职责的好处是可以让我们很容易地来维护这个对象，比如，当一个对象封装了很多职责的时候，一旦一个职责需要修改，势必会影响该对象的其它职责代码。通过解耦可以让每个职责更加有弹性地变化。我们来看看jQuery文档针对业务层的Ajax的处理提供了一系列的门面接口： undefined 底层接口： undefined 快捷方法： undefined jQuery接口的设计原理业务逻辑是复杂多变的，jQuery的高层API数量非常多，而且也非常的细致，这样做可以更友好的便于开发者的操作，不需要必须在一个接口上重载太多的动作。我们在深入内部看看Ajax的高层方法其实都是统一调用了一个静态的jQuery.ajax方法，代码见右侧代码编辑器（27-43行）。在jQuery.ajax的内部实现是非常复杂的，首先ajax要考虑异步的处理与回调的统一性，所以就引入了异步队列模块（Deferred）与回调模块（Callbacks）, 所以要把这些模块方法在ajax方法内部再次封装成、构建出一个新的jQXHR对象，针对参数的默认处理，数据传输的格式化等等。 慕课网慕课老师说： jQuery是如何处理命名空间让我们开始学习下jQuery是如何处理命名空间中变量名污染的问题的。没在学习之前，我们想想如何创建一个给自己使用的方法或者变量？ 1、原始写法可能就只是简单的放在了一块了 123456 function m1()&#123; //... &#125; function m2()&#123; //... &#125; 很明显，这就是在全局在window污染了这个window变量，你可以同时在任意位置调用 123m1()//或者window.m1() 2、对象的方式把一个模块写成一个对象，把模块的成员都放在这个对象里就不会污染全局了 123456789var module1 = new Object(&#123; _count: 0, m1: function()&#123; //…dosomething &#125;, m2:function()&#123; //..do otherthing &#125;&#125;) 使用的时候你就可以调用对象里的属性就可以了 1module1.m1() 但是这样会暴露对象中私有变量，这在C#，C++都是有private可以用来保护的，换另一种吧。 3、立即执行函数写法让我首先学习一下什么叫立即执行函数（Immediately-Invoked Function Expression，IIFE）其实我现在也只是懂一点而已，大致说下首先我们先要理解下Javascript中比较特别的一点（这类特点十分多），叫做高阶函数（Higher-order function）理解这一点之前呢，我还需要说明一点的就是JavaScript中的什么变量都是一个对象，不过其中比较特殊的一点就是函数对象，他们除了可以将变量成为一个函数，比如 1var sum = function(x, y)&#123;return x + y;&#125; 也可以在JavaScript中当一个类来使用 12345678function Person(name) &#123; this.name = name; this.greeting = function() &#123; alert(&apos;Hi! I\&apos;m &apos; + this.name + &apos;.&apos;); &#125;;&#125;var person1 = new Person(&apos;Bob&apos;);var person2 = new Person(&apos;Sarah&apos;); 讲完函数也是一个特殊的变量之后，我们就将一起混合使用一下 12var f = function(x,y,fun)&#123;return fun(x,y);&#125;f(1,2,sum)//3 或者我们再讲一个比较抽象的函数吧 12345678var pow = function(n)&#123; return function(x)&#123; return Math.pow(x,n); &#125;&#125;var pow2 = pow(2);// var pown = pow(n) Pseudocodepow2(2);//4 像这样类似的不返回的是值，而是一个定义了的函数，再举一个没有参数的例子可能会更加形象点： 1234567function lazy_sum(arr)&#123; return function sum ()&#123; return arr.reduce(function(x, y)&#123; return x+y; &#125;) &#125;&#125; 也可以写成这样 12345678function lazy_sum(arr) &#123; var sum = function () &#123; return arr.reduce(function (x, y) &#123; return x + y; &#125;); &#125; return sum;&#125; 当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数： 1var f = lazy_sum([1, 2, 3, 4, 5]); // function sum() 调用函数f时，才真正计算求和的结果： 1f(); // 15 在一个lazy_sum函数中又定义了sum函数，内部函数sum引用了lazy_sum的参数，重点是这个引用是自上而下的，在使用时，赋值f的值先要定义arr也就是lazy_sum中的参数，再调用f()时，并没有参数的传递。当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。但是这类闭包虽然用起来很方便，但当它碰到循环或者更直接些，遇到返回的函数中有变量能将其中的函数改变的时候，这就出现了问题了 123456789101112131415function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push(function () &#123; return i * i; &#125;); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2]// 注意 arr返回的是一个匿名函数数组[function()&#123;&#125;,function()&#123;&#125;,function()&#123;&#125;] 注意由于是闭包（Closure）的特性 123f1()//16f2()//16f3()//16 由于返回的函数中引用了i这个变量，在var results = count();时，Closure中的i值早已变为4，所以结果都为16，问我怎么看到i值的，我用chrome查看到的。返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。如果你一定要用循环并且一定要使用的时i这个变量怎么办？那就要用标题所说的立即函数写法，也就是去创建一个匿名函数并立即执行的语法 123(function (x) &#123; return x * x;&#125;)(3); // 9 这里闭包谈的很多了，也参考了许多大佬们的资料了，其实真正要谈的时闭包在面向对象中充当一个priavte的一个修饰词，其实也是在模块中防止类似方式二中所暴露的问题，私有变量可以不会修改， 123456789var module4 = (function()&#123; var _count = 0; return &#123; m1: function()&#123; _count++; return _count; &#125; &#125;&#125;)() 很明显利用立即函数的写法()()，可以直接在全局中模块中的暴露函数，比如module4.m1()但是不用立即函数的写法，闭包的延迟特性也就体现出来了， 123456789var module3 = function()&#123; var _count = 0; return &#123; m1: function()&#123; _count++; return _count; &#125; &#125;&#125; 在全局中module3只是一个返回函数，可以理解为一个待new的一个类，必须 1var c = module3(); 然后在调用c.m1()才能正确使用4、去放大一个模块（放大模式）如果一个模块越来越大，有必要将模块分块，或者说去继承另一个必要的模块，这时就必须用这样的一个写法当然这样的写法只适用与立即函数写法，如果不懂什么原理去引用了module3的这个返回来的函数会报module5.m1 is not a function因为毕竟module3中的m1还只是个抽象的东西，不是实际存在的模块或者说可用对象。 12345678var module5 = (function (mod)&#123;//当然你也可以自我更新,这里些module4 var _sub = 10; mod.m2 = function()&#123; _sub--; return _sub; &#125; return mod;&#125;)(module4);//一定时module4不时module3哦 5、宽放大模式（Loose augmentation）在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”。 12345678var module6 = ( function (mod)&#123; var _muli = 1; mod.m3 = function()&#123; _muli *= 2; return _muli; &#125; return mod;&#125;)(window.module5 || &#123;&#125;);//为什么用window，我认为是为了确保拿到的是全局变量下的mod，以免取到当前变量中的重复变量引发不可预料的错误。 与”放大模式”相比，＂宽放大模式＂就是”立即执行函数”的参数可以是空对象。6、输入全局变量独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。为了在模块内部调用全局变量，必须显式地将其他变量输入模块。 123var module1 = (function ($, YAHOO) &#123; //...&#125;)(jQuery, YAHOO); 上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。这方面更多的讨论，参见Ben Cherry的著名文章《JavaScript Module Pattern: In-Depth》。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>前端</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git中的平行时空-分支Branch]]></title>
    <url>%2F2017%2F06%2F20%2FGit-branch%2F</url>
    <content type="text"><![CDATA[本文大多数引用廖老师的教程–@git教程http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 分支管理分支这个概念是很神奇的，你不仅可以用来开发，对我来说还可以用特别的软件观察出你的这个项目到底有多么宏伟（虽然现在只是空谈。。） 分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。 如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！ 分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。 现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。 但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。 创建与合并分支在重拾篇中，我们已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长，当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 解决冲突人生不如意之事十之八九，合并分支往往也不是一帆风顺的。 准备新的feature1分支，继续我们的新分支开发： $ git checkout -b feature1Switched to a new branch ‘feature1’ 修改readme.txt最后一行，改为： Creating a new branch is quick AND simple. 在feature1分支上提交： $ git add readme.txt$ git commit -m “AND simple”[feature1 75a857c] AND simple 1 file changed, 1 insertion(+), 1 deletion(-) 切换到master分支： $ git checkout masterSwitched to branch ‘master’Your branch is ahead of ‘origin/master’ by 1 commit. Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。 在master分支上把readme.txt文件的最后一行改为： Creating a new branch is quick &amp; simple. 提交： $ git add readme.txt$ git commit -m “&amp; simple”[master 400b400] &amp; simple 1 file changed, 1 insertion(+), 1 deletion(-) 现在，master分支和feature1分支各自都分别有新的提交，变成了这样： 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看： $ git merge feature1Auto-merging readme.txtCONFLICT (content): Merge conflict in readme.txtAutomatic merge failed; fix conflicts and then commit the result. 果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件： 12345678910$ git status# On branch master# Your branch is ahead of &apos;origin/master&apos; by 2 commits.## Unmerged paths:# (use &quot;git add/rm &lt;file&gt;...&quot; as appropriate to mark resolution)## both modified: readme.txt#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 我们可以直接查看readme.txt的内容： 123456789Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存： Creating a new branch is quick and simple. 再提交： $ git add readme.txt$ git commit -m “conflict fixed”[master 59bc1cb] conflict fixed 现在，master分支和feature1分支变成了下图所示： 用带参数的git log也可以看到分支的合并情况： 12345678910111213* 2671404 conflict fixed|\| * 791d353 AND simple* | 68c7116 &amp; simple|/* 2605498 branch test* 8dc924a add test.txt* 17f0247 add of files* 381cacb git tracks changes* 7e2984e learn git stage is important* 4db1f01 append GPL* 7c17cad add distributed* bb08438 wrote a readme file 最后，删除feature1分支： $ git branch -d feature1Deleted branch feature1 (was 75a857c).]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git远程仓库]]></title>
    <url>%2F2017%2F06%2F18%2FGit%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[本文大多数引用廖老师的教程–@git教程http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 SSH命令去创建RSA密钥实现完自己本地的git添加与提交，并大致了解stage与工作区的概念之后，我们应该去实现一些更加有实用作用的任务了。 没错，就是去学习git的分布式distrubed的功能，以防止硬盘奔溃的情况，还有一起协作完成一个项目的作用。 Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。 你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？ 其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。 实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。 完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。 在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH 在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： $ ssh-keygen -t rsa -C “youremail@example.com“ 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： 点“Add Key”，你就应该看到已经添加的Key： 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。 确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。 小结“有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机 添加远程仓库现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 注册登陆github的账户首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库： 在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： $ git remote add origin git@github.com:/learngit.git 请千万注意，把上面的&lt;yourusername&gt;替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上： $ git push -u origin master 不过如果你是第一次的话会遇到这类问题 The authenticity of host ‘github.com (192.30.255.112)’ can’t be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? 你可以选择yes，让git知道并信任github.com ssh git@github.com 也就是老师说的ssh警告 SSH警告当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告： The authenticity of host ‘github.com (xx.xx.xx.xx)’ can’t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。 Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了： Warning: Permanently added ‘github.com’ (RSA) to the list of known hosts.这个警告只会出现一次，后面的操作就不会有任何警告了。 如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。 小结要关联一个远程库，使用命令git remote add origin ``git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 重拾篇]]></title>
    <url>%2F2017%2F06%2F17%2Fgit%E9%87%8D%E6%8B%BE%E7%AF%87%2F</url>
    <content type="text"><![CDATA[版本回退本文大多数引用廖老师的教程–@git教程http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 当你需要回到之前某个版本的时候，git的真正用处就达到了 GIT LOG 官方说明NAMEgit-log - Show commit logs SYNOPSIS1$ git log [&lt;options&gt;] [&lt;revision range&gt;] [[\--] &lt;path&gt;…​] ### DESCRIPTION Shows the commit logs. The command takes options applicable to the git rev-list command to control what is shown and how, and options applicable to the git diff-* commands to control how the changes each commit introduces are shown.@git官方文档git-scm.com/docs/git-log 根据官方文档来说就是展示你之前提交的commit的log信息如果单单使用git log这条命令它会展示的信息有commit idAuthor name&lt;email&gt;Date time加上 一条commit当时的注释说明如果想看得更加清楚一些 可以单行显示一个版本 1$ git log --pretty=oneline 你大可以把它想象成一条时间线，这三个事件按照某种方式连接着，有这样抽象的概念之后，你就可以知道如何回去之前某个版本是如何实现了 git中，HEAD记录现在的commit id也就是为什么你现在的项目打开是你现在所想要的内容，不过我们现在需要回到上一个版本，也就是让HEAD存储上一个版本的commit id怎么做呢？ 1$ git reset --hard HEAD &lt;commit id&gt; 或如只是单单回到上一个版本有其他简单的方法 1$ git reset --hard HEAD^ 上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。但是，如果我们后悔回退了怎么办？比如之前有比较重要的信息办法其实就还是那些，只要你记住了那些版本号就可以回去，所以一般你的命令行不要关闭，版本号的信息还存留在你的缓存区Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL： 改为指向add distributed： 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？ 在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令： 12345$ git reflogea34578 HEAD@&#123;0&#125;: reset: moving to HEAD^3628164 HEAD@&#123;1&#125;: commit: append GPLea34578 HEAD@&#123;2&#125;: commit: add distributedcb926e7 HEAD@&#123;3&#125;: commit (initial): wrote a readme file 终于舒了口气，第二行显示append GPL的commit id是3628164，现在，你又可以乘坐时光机回到未来了。 小结现在总结一下： HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 工作区和暂存区Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 工作区（Working Directory）就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区： 版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 分支和HEAD的概念我们以后再讲。前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容： Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage. 然后，在工作区新增一个LICENSE文本文件（内容随便写）。先用git status查看一下状态： 1234567891011121314$ git status# On branch master# Changes not staged for commit:# (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)# (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)## modified: readme.txt## Untracked files:# (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)## LICENSEno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下： 12345678$ git status# On branch master# Changes to be committed:# (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)## new file: LICENSE# modified: readme.txt# 现在，暂存区的状态就变成这样了： 所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 123$ git status# On branch masternothing to commit (working directory clean) 现在版本库变成了这样，暂存区就没有任何内容了： 小结 暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。 没弄明白暂存区是怎么回事的童鞋，请向上滚动页面，再看一次。 管理修改现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容： $ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes. 然后，添加： 12345678$ git add readme.txt$ git status# On branch master# Changes to be committed:# (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)## modified: readme.txt# 然后，再修改readme.txt： $ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files. 提交： 123$ git commit -m &quot;git tracks changes&quot;[master d4f25b6] git tracks changes 1 file changed, 1 insertion(+) 提交后，再看看状态： 123456789$ git status# On branch master# Changes not staged for commit:# (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)# (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)## modified: readme.txt#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 咦，怎么第二次的修改没有被提交？别激动，我们回顾一下操作过程：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。提交后，用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别： 1234567891011$ git diff HEAD -- readme.txt diff --git a/readme.txt b/readme.txtindex 76d770f..a9c5755 100644--- a/readme.txt+++ b/readme.txt@@ -1,4 +1,4 @@ Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage.-Git tracks changes.+Git tracks changes of files. 可见，第二次修改确实没有被提交。那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit 好，现在，把第二次修改提交了，然后开始小结。 小结现在，你又理解了Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。 撤销修改自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行： 123456$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN. 在你准备提交前，一杯咖啡起了作用，你猛然发现了“stupid boss”可能会让你丢掉这个月的奖金！既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下： 123456789$ git status# On branch master# Changes not staged for commit:# (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)# (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)## modified: readme.txt#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 你可以发现，Git会告诉你，git checkout -- file可以丢弃工作区的修改：$ git checkout -- readme.txt命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次git commit或git add时的状态。现在，看看readme.txt的文件内容： 12345$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files. 文件内容果然复原了。git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了： 1234567$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN.$ git add readme.txt 庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交： 1234567$ git status# On branch master# Changes to be committed:# (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)## modified: readme.txt# Git同样告诉我们，用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区： 123$ git reset HEAD readme.txtUnstaged changes after reset:M readme.txt git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。再用git status查看一下，现在暂存区是干净的，工作区有修改： 123456789$ git status# On branch master# Changes not staged for commit:# (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)# (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)## modified: readme.txt#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 还记得如何丢弃工作区的修改吗？ 1234$ git checkout -- readme.txt$ git status# On branch masternothing to commit (working directory clean) 整个世界终于清静了！现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把“stupid boss”提交推送到远程版本库，你就真的惨了……小结又到了小结时间。场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 中的 Function 函数]]></title>
    <url>%2F2017%2F06%2F13%2Fjavascript%E4%B8%AD%E7%9A%84Function%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[本文引用的部分链接https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript#内部函数https://stackoverflow.com/questions/111102/how-do-javascript-closures-workhttps://translate.google.cn/#en/zh-CN/Local%20variables%20that%20end%20up%20within%20closurehttps://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Inheritance 面试题强力分析:记住这天，人生第一次在场笔试失利，虽然是自己在基础方面不够过关，但是我认为前端对于程序员来说，难度最大的还是在背诵方面，需要记忆的东西还是比一般的来说太多了，比如有一题我真的很少用原生的Js的控制Dom的习惯，题目是div自身点击，然后删除自己本身。哇，现在看看真的是简单；笔试的时候没有工具是一件十分恶心的事，对于我来说！ 还有一题也是比较恶心，不是我觉得它难，而是觉得它让我回到了高考那个看题时代，题目是这样的：让一个div垂直水平居中。 具体可以参考别人的想法http://blog.csdn.net/freshlover/article/details/11579669慕课前端面试图片第一，我让有点印象这道题，没错就如同高考中可能会遇到类似题型的感觉 第二点，我就想到你这题没有说用css还是js啊，虽然js我可能不会，但是你不说明的话，只能怪我不客气了，我要写css！ 所以第三点我就非常气，css写垂直水平居中到底是什么概念啊！我百度了下就是完全处于中心，嗯，这点我懂了，可以用绝对位置去应对先看答案 垂直居中呢？而且200px与200pxd的宽度呢？这都是wrapper没有高度惹的祸理论上应在根据窗口自适应是最好的，但这肯定要用到js方面的知识这样不是也可以用margin了吗？甚至效果更好不是吗？ 其他都不说了，最气的还是有一题根本没遇到过这样的情况，来当作面题了题目是这样的：利用js代码实现add(1)(2)和add(1,2)题目的思想很明显当你在命令行敲入add(1,2)返回3同样的是add(1)(2)也要返回3这样的写法在任何语言都是一种语法的报错，但是在js就不同了，可以当时的我真没遇到这样的写法，在写项目也没有老师会用这样的写法，真的是日了狗了，好吧，他就是考的是基础然后回到寝室，我开始奋力补习，亲切的打开MDN专业文档https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Basics先盲目补习下对象的知识主要现在是正文真正的开始，js中的function是真的重要 Js中的对象空对象的定义十分简单 1var person = &#123;&#125;; 复杂的对象 123456789101112var person = &#123; name : ['Bob', 'Smith'], age : 32, gender : 'male', interests : ['music', 'skiing'], bio : function() &#123; alert(this.name[0] + ' ' + this.name[1] + ' is ' + this.age + ' years old. He likes ' + this.interests[0] + ' and ' + this.interests[1] + '.'); &#125;, greeting: function() &#123; alert('Hi! I\'m ' + this.name[0] + '.'); &#125;&#125;; 其实，js中几乎什么都是一个对象，比如 1myString.split(','); myString继承了String的split方法还有写DOM的对象这里就不详细地往下讲了 这里讲完对象就不得不讲讲对象中类，类不是js独创，不过在许多语言都用class这个概念，在php，java，c++，c#等等都可以看到class的使用其实就是为了继承，比如 一个Person 类在一个Person的基础上你不仅可以创造一个名为王小波的一个具体人的对象你甚至可以继承Person类去创建一个新的，属于某个更加具体的类，比如老师Teacher()类Student()类 其中属性的继承或者方法的重写都是一种很好的代码循环利用，在程序猿的世界，这叫做防止代码冗余，易于别人或自己看懂代码 对象的构造初始化 类的继承 类继承后可以继续创造相应的对象 不过在Js是如何处理这类OOP理论的问题呢引用MDN中的一句话， Some people argue that JavaScript is not a true object-oriented language — for example it doesn’t have a class statement for creating classes like many OO languages. JavaScript instead uses special functions called constructor functions to define objects and their features. They are useful because you’ll often come across situations in which you don’t know how many objects you will be creating; constructors provide the means to create as many objects as you need in an effective way, attaching data and functions to them as required. 来自 https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object-oriented_JS Js似乎与其他语言不太一样，它并没有class的语法，在es5中，Js利用的是Function这种特殊的函数去代替class类，这在js中叫做构造器函数 其实这里有的跑题了，但还是要稍微讲一下js中比较正规的创建一个类的方法是 123456789// 构造器及其属性定义function Test(a,b,c,d) &#123; // 属性定义&#125;;// 定义第一个方法Test.prototype.x = function () &#123; ... &#125;// 定义第二个方法Test.prototype.y = function () &#123; ... &#125;// 等等…… 一个类的方法定义在外面，方法与类之间加prototype原型这个单词 讲完对象，让我们与内部函数或者说闭包做一下对比https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript#内部函数这里它举例到有一种闭包的例子 123456789function makeAdder(a) &#123; return function(b) &#123; return a + b; &#125;&#125;var x = makeAdder(5);var y = makeAdder(20);x(6); // ?y(7); // ? 这里不是直接告诉我们答案了吗这里的makeAdder(a)(b)肯定是可以所以这道面试一下子就可以解决了 其实这种写法叫做“柯里化”（’currying’）What’s the currying?也就是所有多参数的函数，都可以默认单参数去使用。这是一种Javascript函数式编程种最理想的工具库 让我们无聊一把，如果参数无数呢？就是add()()()()()()…和add(1,2,3,4,5,6,7,8,….)这样的问题，如果下次面试是这个怎么办？很明显，第二个还是很好解决的，第一就是要用到循环调用函数的问题了 函数中循环调用子函数，直到没有()，也就是函数的调用，返回最终x的值]]></content>
      <categories>
        <category>技术</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>前端</tag>
        <tag>柯里化</tag>
        <tag>currying</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我对自己的一些认知]]></title>
    <url>%2F2017%2F04%2F08%2F%E6%88%91%E5%AF%B9%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[现在写这篇文章的时候，我已经大三，也就是即将进入大四的时间段。对这三年而言，我虽然目标不定，但是一直都在做自己喜欢做的事情，大一的时候学学C语言，去集训队参加过一些小型比赛，不过Acm这类算法毕竟有些枯燥，也只是笔头的练习你的动脑能力，所以我在这个原因和我学的硬件的情况下我退出了这个强大的队伍。 大一大一的我依然对美有过追求，在大学的记者团出过好几张板报，而且不仅仅能在记者团，参加过的社团几乎都让我出版报。当然这种板报这是PS这类软件做的喽，不是手绘这种我看起来比较累人的活。毕竟我从小画画的基础在大学我看完全丧失了吧… 这是我第一次用PS PhotoShop CS6按照学长的要求去做的海报，当这个海报真的被打印出来的时候真的很开心 最后一张应该是结束之作吧.渐渐任务变得重复了，不在存有一点新鲜感了，选择在大二时候隐退。 做了还有很多不是记者团的海报，这里有的找不出来就不发了。我记得有次很自豪的还对室友说，你看啊，这些(手在空中飞舞)海报都是我做的呢!整个学校的海报都是出自我之手，(那时真的特别开心，而且真的有3张海报同时挂在学校的各个地方)除了在记者团，我还在当初所为的艺术团待过，那边也是活力四射的社团，学生都在拼命的展示自己的才艺，一天到晚。当然我并没有什么才艺，最多的时候也只是碰碰单反，拍拍视频，管理搭建微博墙，谁叫我们是媒体部呢!不过长得美的人果然很多在那儿，不过也不排除这个社团本身人就很多，占了学校的1/3的人。 所在我在那儿也结交了一些会做视频的人群，自己也会一些PR，AE技术.做过微电影《光》–这是不讲爱情的故事，但是是爱让TA们俩相遇 同样欢迎大家能来我的优酷视频站 大二总该学点有用的知识了吧，毕竟我感觉我们专业的方向不太明确，也不能坐着等屎吧… 除了进入了我们学院的大学生科技创业中心，也同样在老师的推荐下当了个假的OJ管理员，不过当了之后学长讲的东西也是启发了我该学什么语言，因为OJ是用PHP写的所以慢慢去学了，学了之后在中心的能力比别人倒是强了不少，毕竟PHP写网站的速度很快，语法简单，易于学习.不想JAVA，C#不仅IDE超大，复杂，每次的使用要引用对应的包。 可以说是在中心的熏陶下，我发现自己与他人与众不同之处了，而且在中心，这里他们不约束学生的想法，想做就去做，会给你支持，会有很多人来帮助你测试你的项目，是你的项目更加顽健.指导老师也十分支持我，比如不用来一些浪费你时间的会议，别人不可以，我却可以，这让我更加觉得这里是我能够充分发挥我的想法的地方。 所以我会经常推荐学弟学妹们来我们中心，这里不会像学生会那样严格，约束，提供了很好的环境。 就这样，我依靠当时的对web的知识，完成一个简陋的项目(在现在看来，这个项目真是有好看的外表，不堪入目的内部结构，我现在都不想再去修改它了，它简直不可理喻，难以维护) 它叫报名管理系统，基于Tp3搭建的. GITHUB LimonStudio个人主页大三 我进了硬件实验室 叫 电类实验室，那里的牛人也多，有个学长进大疆我记得。 不过我还是应为那里的设备很少，实验室很远，来去不方便，管理松散，为自己找理由吧.现在已经不去了，不过大三开始前暑假有在呆在那儿一会儿过，那边有个马哥算是比较熟啦，他人缘好广，前几个月也找到自己的另一半啦(羡慕// _ //)我和他为老师(是另一个实验室(物联网)的老师做过zigbee的项目，叫做所有权的转换，也算是完成了3个专利吧.然后我就退了，因为也是任务重复度太高，没了兴致。 你可能会问，我怎么不去利用设备去玩转下物联网呢?毕竟这个也是比较火的方向.我想过，不过就目前而言，我也不想毫无头绪，还是先从事软件的行业比较稳妥，另一个就是硬件比较烧钱，作为学生的我还是看看就好….对，怂了。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>ME</tag>
      </tags>
  </entry>
</search>
